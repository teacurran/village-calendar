# Project Plan: Village Calendar

**Version:** 1.0
**Date:** 2025-10-16
**Generated By:** Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

---

<!-- anchor: project-overview -->
## 1. Project Overview

<!-- anchor: goal -->
### Goal

Build a full-stack web application enabling users to create, customize, and order professional-quality full-year calendars with astronomical data integration, e-commerce fulfillment, and administrative management capabilities.

<!-- anchor: high-level-requirements -->
### High-Level Requirements Summary

- **Calendar Creation & Editing**: Browser-based editor for custom calendars with templates, events, emojis, holidays, and astronomical overlays (moon phases, Hebrew calendar)
- **User Management**: OAuth authentication (Google/Facebook/Apple), anonymous session persistence, account management
- **PDF Generation**: High-resolution PDF export with watermarking for free tier, asynchronous job processing
- **E-Commerce**: Stripe payment integration, order lifecycle management, email notifications, shipping tracking
- **Admin Panel**: Template creation, order management dashboard, business analytics, user support tools
- **Infrastructure**: Kubernetes deployment, Cloudflare CDN/edge services, PostgreSQL database, distributed tracing/monitoring
- **Security**: HTTPS everywhere, CSRF protection, input validation, PCI compliance (via Stripe), GDPR/CCPA compliance

<!-- anchor: key-assumptions -->
### Key Assumptions

**Technical Stack:**
- Quarkus 3.26.2 (Java 21) backend with Vue 3.5+ (Composition API) frontend is mandated and team has expertise
- PostgreSQL 17+ with PostGIS supports astronomical calculations and relational e-commerce data
- Existing DelayedJob pattern (Vert.x EventBus + database queue) proven in VillageCMS prototype
- Kubernetes (k3s on Proxmox) infrastructure operational with Cloudflare integration

**Business Assumptions:**
- Initial target market: B2C individual consumers (US-focused, English-only for MVP)
- Seasonal demand peaks Q4 (November-January) requiring 3-5x capacity scaling
- Print-on-demand partner model preferred over in-house printing (MVP)
- Free tier uses watermarked PDFs to drive paid conversion
- Standard fulfillment SLA: 3-5 business days acceptable for initial launch
- Marketing via organic SEO and content (no paid acquisition budget initially)

**Environmental Assumptions:**
- GitHub Actions CI/CD with WireGuard VPN to Proxmox k3s operational
- Cloudflare Tunnel provides secure ingress without exposing infrastructure IPs
- GoogleWorkspace SMTP sufficient for <10k emails/month (migrate to AWS SES if volume increases)
- Team size: 2-3 developers with Java/Quarkus and Vue.js expertise
- Reference prototype in `/Users/tea/dev/VillageCompute/code/VillageCMS/admin` (read-only)

---

<!-- anchor: core-architecture -->
## 2. Core Architecture

<!-- anchor: architectural-style -->
### Architectural Style

**Modular Monolith with Asynchronous Job Processing**

Single Quarkus application deployed to Kubernetes with clear internal module boundaries:
- `calendar-core`: Calendar domain logic, astronomical calculations, templates
- `calendar-pdf`: PDF generation engine (Batik SVG rendering, watermarking)
- `user-management`: OAuth authentication, account management
- `commerce`: Order management, Stripe integration, payment processing
- `jobs`: DelayedJob framework, async job definitions
- `admin`: Administrative interfaces, analytics
- `web-api`: GraphQL schema, REST controllers, Vue.js SPA integration (Quinoa)

**Rationale**: Simpler operations for small team, strong transactional consistency for e-commerce, faster development velocity. Designed for future extraction of modules (e.g., PDF service) if independent scaling required.

<!-- anchor: technology-stack -->
### Technology Stack

**Backend:**
- Framework: Quarkus 3.26.2
- Runtime: Java 21 (OpenJDK LTS)
- ORM: Hibernate ORM with Panache (active record pattern)
- Database: PostgreSQL 17+ with PostGIS extensions
- API: GraphQL (SmallRye GraphQL) primary, REST (JAX-RS) for webhooks/health checks
- Job Processing: Custom DelayedJob + Vert.x EventBus, Quarkus Scheduler
- Authentication: Quarkus OIDC (OAuth 2.0 / OpenID Connect)
- Observability: OpenTelemetry → Jaeger (tracing), Micrometer → Prometheus (metrics)
- PDF Generation: Apache Batik 1.17 (SVG to PDF)
- Astronomical Calcs: SunCalc (port), Proj4J 4.1

**Frontend:**
- Framework: Vue 3.5+ (Composition API)
- UI Library: PrimeVue 4.2+ (Aura theme)
- Icons: PrimeIcons 7.0+
- CSS: TailwindCSS 4.0+
- State Management: Pinia
- Routing: Vue Router 4.5+
- I18n: Vue I18n (future localization)
- Build Tool: Vite 6.1+
- TypeScript: ~5.7.3
- Integration: Quinoa plugin (Quarkus-Vue seamless integration)

**Infrastructure:**
- Container Runtime: Docker
- Orchestration: Kubernetes (k3s on Proxmox)
- IaC: Terraform 1.7.4 (Cloudflare, AWS resources)
- Config Management: Ansible
- Database Migrations: MyBatis Migrations
- CDN/Edge: Cloudflare CDN, DNS, DDoS protection
- Tunnel: Cloudflare Tunnel (secure k3s ingress)
- VPN: WireGuard (CI/CD access)
- Object Storage: Cloudflare R2 (S3-compatible)
- Email: GoogleWorkspace SMTP (migrate to AWS SES if needed)
- CI/CD: GitHub Actions

**External Services:**
- Payment Processing: Stripe (Checkout Sessions, webhooks)
- OAuth Providers: Google, Facebook, Apple

<!-- anchor: key-components-services -->
### Key Components/Services

**Backend Components:**
1. **GraphQL API Layer**: Query/mutation resolvers, schema definition, DataLoader pattern for N+1 prevention
2. **Calendar Service**: CRUD operations, template application, event management, astronomical calculations
3. **User Service**: OAuth integration, session conversion (guest → authenticated), profile management
4. **Order Service**: Order placement, Stripe checkout creation, payment webhook handling, status updates
5. **PDF Service**: Job enqueueing, watermark logic, R2 upload coordination
6. **Job Manager**: DelayedJob queue management, EventBus publishing, priority assignment, retry logic
7. **Email Service**: Transactional email composition (order confirmations, shipping updates), SMTP delivery
8. **Repository Layer**: Panache repositories for User, Calendar, Order, DelayedJob, Template entities
9. **Security Layer**: JWT validation, RBAC enforcement, CSRF protection

**Frontend Components:**
1. **Calendar Editor**: Drag-drop event creation, emoji picker, holiday set selection, astronomical overlay toggles
2. **Template Gallery**: Browse/preview admin-curated templates, "Start from Template" flow
3. **User Dashboard**: My Calendars list (grid/list view), order history, account settings
4. **Checkout Flow**: Cart review, shipping address form, Stripe Checkout integration
5. **Admin Panel**: Template management, order processing dashboard, analytics visualization

**Async Job Workers:**
1. **PDF Generation Job**: Batik rendering, watermarking, R2 upload, calendar entity update
2. **Email Job**: Transactional email sending with retry logic
3. **Analytics Rollup Job**: Daily/weekly aggregation of page views, orders, revenue

**Key Diagrams Planned:**
- Component Diagram (PlantUML): Quarkus API internal components, dependencies (Created in Iteration 1)
- Database ERD (PlantUML): Entity relationships for users, calendars, orders, jobs (Created in Iteration 1)
- Sequence Diagrams (PlantUML): OAuth login flow, order placement flow, PDF generation flow (Created in Iteration 2)
- Deployment Diagram (PlantUML): Kubernetes topology, Cloudflare integration (Created in Iteration 1)

<!-- anchor: data-model-overview -->
### Data Model Overview

**Core Entities:**

1. **User**: OAuth-authenticated accounts
   - Fields: `user_id` (PK), `oauth_provider`, `oauth_subject_id`, `email`, `display_name`, `profile_picture_url`, `role` (user/admin)
   - Relationships: 1:N with Calendars, Orders, CalendarTemplates

2. **CalendarSession**: Anonymous guest sessions (pre-authentication)
   - Fields: `session_id` (PK, UUID), `user_id` (nullable FK), `session_data` (JSONB), `expires_at`
   - Purpose: Persist guest calendar edits, convert to user account on login

3. **Calendar**: User's saved calendars
   - Fields: `calendar_id` (PK), `user_id` (FK), `template_id` (FK, nullable), `title`, `year`, `config` (JSONB), `preview_image_url`, `pdf_url`, `is_public`, `share_token` (UUID), `version` (optimistic locking)
   - Relationships: 1:N with Events, N:1 with User/Template

4. **Event**: Custom calendar events
   - Fields: `event_id` (PK), `calendar_id` (FK), `event_date`, `event_text`, `emoji`, `color`

5. **CalendarTemplate**: Admin-created templates
   - Fields: `template_id` (PK), `created_by_user_id` (FK), `name`, `description`, `thumbnail_url`, `config` (JSONB), `is_active`, `sort_order`

6. **Order**: E-commerce orders
   - Fields: `order_id` (PK), `user_id` (FK), `order_number`, `status` (enum: PENDING/PAID/IN_PRODUCTION/SHIPPED/DELIVERED/CANCELLED/REFUNDED), `subtotal`, `tax`, `shipping_cost`, `total`, `shipping_address` (JSONB), `tracking_number`
   - Relationships: 1:N with OrderItems, 1:1 with Payment

7. **OrderItem**: Line items in orders
   - Fields: `order_item_id` (PK), `order_id` (FK), `calendar_id` (FK), `product_type`, `quantity`, `unit_price`

8. **Payment**: Stripe payment records
   - Fields: `payment_id` (PK), `order_id` (FK), `stripe_payment_intent_id`, `stripe_checkout_session_id`, `amount`, `status`, `refund_amount`, `refund_reason`

9. **DelayedJob**: Asynchronous job queue
   - Fields: `job_id` (PK), `job_type`, `payload` (JSONB), `priority`, `attempts`, `max_attempts`, `run_at`, `locked_at`, `locked_by`, `failed_at`, `last_error`, `completed_at`

10. **PageView**: Analytics events
    - Fields: `page_view_id` (PK), `user_id` (FK, nullable), `session_id` (FK, nullable), `url_path`, `referrer`, `user_agent`, `ip_address`, `created_at`

11. **AnalyticsRollup**: Aggregated metrics
    - Fields: `rollup_id` (PK), `rollup_date`, `metric_name`, `metric_value`, `dimensions` (JSONB)

**Database Indexing Strategy:**
- Primary keys: `bigserial` auto-increment
- Foreign keys with indexes: `user_id`, `calendar_id`, `order_id`, `session_id`
- Composite indexes: `(user_id, created_at)`, `(order_id, status)`, `(run_at, priority)` on delayed_jobs
- Unique constraints: `users.email`, `orders.order_number`, `calendar.share_token`
- GIN indexes on JSONB: `calendar.config`, `analytics_rollups.dimensions`

**ERD Diagram**: Generated in Iteration 1 (PlantUML format, stored in `docs/diagrams/database_erd.puml`)

<!-- anchor: api-contract-style -->
### API Contract Style

**Primary: GraphQL (SmallRye GraphQL)**

**Endpoint**: `POST /graphql`

**Schema Evolution**: Additive-only changes, field deprecation with `@deprecated` annotation, no versioning required for MVP

**Key Queries:**
- `calendar(id: ID!): Calendar`
- `calendars(userId: ID!, year: Int): [Calendar!]!`
- `templates(isActive: Boolean): [CalendarTemplate!]!`
- `order(orderId: ID!): Order`
- `orders(userId: ID!, status: OrderStatus): [Order!]!`

**Key Mutations:**
- `createCalendar(input: CreateCalendarInput!): Calendar!`
- `updateCalendar(id: ID!, input: UpdateCalendarInput!): Calendar!`
- `generatePdf(calendarId: ID!, watermark: Boolean!): PdfJob!`
- `placeOrder(input: PlaceOrderInput!): Order!`
- `convertGuestSession(sessionId: ID!): User!`

**Type Safety**: GraphQL schema generates TypeScript types for Vue.js frontend (compile-time validation)

**Secondary: REST (JAX-RS)**

Used for webhooks, health checks, file downloads:
- `POST /api/webhooks/stripe` - Stripe payment webhooks
- `GET /api/downloads/pdf/{calendarId}?token={token}` - PDF download with presigned URL
- `GET /q/health/live` - Kubernetes liveness probe
- `GET /q/health/ready` - Kubernetes readiness probe
- `GET /q/metrics` - Prometheus metrics scraping

**API Specification**: Initial GraphQL schema defined in Iteration 1 (`api/graphql-schema.graphql`), evolves with features

<!-- anchor: communication-patterns -->
### Communication Patterns

**Synchronous Request/Response (GraphQL/REST over HTTPS):**
- Client ↔ API server for real-time operations (calendar CRUD, order placement, authentication)
- Typical latency: <500ms (p95)
- Transactional consistency (database commit before response)

**Asynchronous Job Processing (DelayedJob + Vert.x EventBus):**
- Long-running operations: PDF generation (10-30s), email sending, analytics rollups
- Workflow:
  1. Client → GraphQL mutation → API creates DelayedJob record (status: PENDING)
  2. API publishes event to Vert.x EventBus → returns job ID to client immediately
  3. Job Worker pod consumes event → claims job (locks database row)
  4. Worker executes job logic → updates status (COMPLETED/FAILED)
  5. Client polls job status via GraphQL or receives email notification

**External Service Communication:**
- **Stripe API**: HTTPS/REST for checkout session creation, webhook signature validation
- **OAuth Providers**: HTTPS/OIDC for user authentication, token validation
- **Email Service**: SMTP/TLS for transactional email delivery
- **Cloudflare R2**: S3 API/HTTPS for PDF upload, presigned URL generation

**Key Interaction Flows** (detailed sequence diagrams in Iteration 2):
1. User Login via OAuth (Google/Facebook/Apple)
2. Place Order for Printed Calendar (Stripe Checkout, webhook processing)
3. Asynchronous PDF Generation (job queue, Batik rendering, R2 upload)

---

<!-- anchor: key-architectural-artifacts -->
## 2.1. Key Architectural Artifacts Planned

The following diagrams and specifications will be generated during the iteration plan to clarify design for implementation agents:

<!-- anchor: artifact-component-diagram -->
### 1. Component Diagram (PlantUML)
- **Purpose**: Visualize internal structure of Quarkus API application (services, repositories, integrations)
- **Format**: PlantUML (C4 Component diagram syntax)
- **Location**: `docs/diagrams/component_diagram.puml`
- **Created In**: Iteration 1, Task I1.T3
- **Content**: GraphQL API, Service Layer (Calendar/User/Order/PDF services), Repository Layer, Integration Components (OAuth/Stripe/Email/R2), Security Filter

<!-- anchor: artifact-database-erd -->
### 2. Database ERD (PlantUML)
- **Purpose**: Define entity relationships, primary/foreign keys, indexes
- **Format**: PlantUML entity-relationship syntax
- **Location**: `docs/diagrams/database_erd.puml`
- **Created In**: Iteration 1, Task I1.T4
- **Content**: All entities (User, Calendar, Event, Order, Payment, DelayedJob, etc.), cardinalities, key constraints

<!-- anchor: artifact-deployment-diagram -->
### 3. Deployment Diagram (PlantUML)
- **Purpose**: Show Kubernetes topology, Cloudflare integration, external services
- **Format**: PlantUML (C4 Deployment diagram)
- **Location**: `docs/diagrams/deployment_diagram.puml`
- **Created In**: Iteration 1, Task I1.T5
- **Content**: k3s cluster, API/Worker pods, PostgreSQL VM, Cloudflare edge, Stripe/OAuth providers

<!-- anchor: artifact-sequence-diagrams -->
### 4. Sequence Diagrams (PlantUML)
- **Purpose**: Document key interaction flows (OAuth login, order placement, PDF generation)
- **Format**: PlantUML sequence diagram syntax
- **Location**: `docs/diagrams/sequence_*.puml`
- **Created In**: Iteration 2, Task I2.T1
- **Content**:
  - `sequence_oauth_login.puml`: User authentication via Google/Facebook/Apple
  - `sequence_order_placement.puml`: Stripe checkout, webhook processing, email job
  - `sequence_pdf_generation.puml`: Async job workflow, Batik rendering, R2 upload

<!-- anchor: artifact-graphql-schema -->
### 5. GraphQL Schema Specification (GraphQL SDL)
- **Purpose**: Define API contract for frontend-backend communication
- **Format**: GraphQL Schema Definition Language (.graphql)
- **Location**: `api/graphql-schema.graphql`
- **Created In**: Iteration 1, Task I1.T6
- **Content**: Query/Mutation/Type definitions, input types, enums (OrderStatus, ProductType, etc.)

<!-- anchor: artifact-database-migration-scripts -->
### 6. Database Migration Scripts (SQL)
- **Purpose**: Version-controlled schema evolution
- **Format**: SQL DDL (MyBatis Migrations format)
- **Location**: `migrations/scripts/`
- **Created In**: Iteration 1, Task I1.T7 (initial schema), evolves in subsequent iterations
- **Content**: `001_create_users_table.sql`, `002_create_calendars_table.sql`, etc.

<!-- anchor: artifact-openapi-rest-spec -->
### 7. REST API Specification (OpenAPI 3.0) - Optional/Future
- **Purpose**: Document webhook and download endpoints (secondary to GraphQL)
- **Format**: OpenAPI 3.0 YAML
- **Location**: `api/openapi-rest.yaml`
- **Created In**: Iteration 3 (if needed for external integrations)
- **Content**: `/api/webhooks/stripe` POST, `/api/downloads/pdf/{id}` GET

<!-- anchor: artifact-adr-records -->
### 8. Architectural Decision Records (Markdown) - Optional
- **Purpose**: Document key architectural choices and rationale
- **Format**: Markdown (ADR template)
- **Location**: `docs/adr/`
- **Created In**: Iteration 1, Task I1.T8 (if team adopts ADR practice)
- **Content**: 001-modular-monolith.md, 002-graphql-primary-api.md, 003-async-job-pattern.md

---

<!-- anchor: directory-structure -->
## 3. Directory Structure

**Root Directory**: `village-calendar/`

The proposed structure organizes code by functional domain (modular monolith), with clear separation of backend (Quarkus), frontend (Vue), infrastructure (Terraform/Ansible), and documentation/artifacts.

```
village-calendar/
├── src/                                  # Backend source code (Quarkus application)
│   ├── main/
│   │   ├── java/com/villagecompute/calendar/
│   │   │   ├── api/                     # GraphQL/REST controllers
│   │   │   │   ├── graphql/             # GraphQL resolvers
│   │   │   │   │   ├── CalendarResolver.java
│   │   │   │   │   ├── OrderResolver.java
│   │   │   │   │   └── UserResolver.java
│   │   │   │   └── rest/                # REST controllers (webhooks, downloads)
│   │   │   │       ├── StripeWebhookController.java
│   │   │   │       └── PdfDownloadController.java
│   │   │   ├── service/                 # Business logic layer
│   │   │   │   ├── CalendarService.java
│   │   │   │   ├── UserService.java
│   │   │   │   ├── OrderService.java
│   │   │   │   ├── PdfService.java
│   │   │   │   └── EmailService.java
│   │   │   ├── repository/              # Panache repositories (data access)
│   │   │   │   ├── UserRepository.java
│   │   │   │   ├── CalendarRepository.java
│   │   │   │   ├── OrderRepository.java
│   │   │   │   └── DelayedJobRepository.java
│   │   │   ├── model/                   # JPA entities
│   │   │   │   ├── User.java
│   │   │   │   ├── Calendar.java
│   │   │   │   ├── Event.java
│   │   │   │   ├── Order.java
│   │   │   │   ├── OrderItem.java
│   │   │   │   ├── Payment.java
│   │   │   │   ├── CalendarTemplate.java
│   │   │   │   └── DelayedJob.java
│   │   │   ├── jobs/                    # Async job implementations
│   │   │   │   ├── DelayedJobExecutor.java
│   │   │   │   ├── PdfGenerationJob.java
│   │   │   │   ├── EmailJob.java
│   │   │   │   └── AnalyticsRollupJob.java
│   │   │   ├── integration/             # External service clients
│   │   │   │   ├── stripe/              # Stripe API client
│   │   │   │   ├── oauth/               # OAuth provider integration
│   │   │   │   ├── email/               # SMTP email sender
│   │   │   │   └── r2/                  # Cloudflare R2 client
│   │   │   ├── security/                # Authentication/authorization
│   │   │   │   ├── JwtTokenValidator.java
│   │   │   │   └── RoleBasedAccessControl.java
│   │   │   └── util/                    # Utility classes
│   │   │       ├── astronomical/        # Moon phase, Hebrew calendar calcs
│   │   │       └── pdf/                 # Batik rendering utilities
│   │   └── resources/
│   │       ├── application.properties   # Quarkus configuration
│   │       ├── application-dev.properties
│   │       ├── application-prod.properties
│   │       └── db/migration/            # Flyway migrations (if using Flyway)
│   └── test/
│       └── java/com/villagecompute/calendar/
│           ├── api/                     # API integration tests
│           ├── service/                 # Service unit tests
│           └── repository/              # Repository tests
├── frontend/                             # Vue.js SPA (integrated via Quinoa)
│   ├── src/
│   │   ├── assets/                      # Static assets (images, fonts)
│   │   ├── components/                  # Vue components
│   │   │   ├── calendar/                # Calendar editor components
│   │   │   │   ├── CalendarEditor.vue
│   │   │   │   ├── EventPicker.vue
│   │   │   │   └── EmojiSelector.vue
│   │   │   ├── admin/                   # Admin panel components
│   │   │   ├── checkout/                # Checkout flow components
│   │   │   └── common/                  # Shared components (header, footer)
│   │   ├── views/                       # Page-level components (routes)
│   │   │   ├── Home.vue
│   │   │   ├── CalendarEditor.vue
│   │   │   ├── Dashboard.vue
│   │   │   ├── Checkout.vue
│   │   │   └── AdminPanel.vue
│   │   ├── stores/                      # Pinia state management
│   │   │   ├── user.ts
│   │   │   ├── calendar.ts
│   │   │   └── cart.ts
│   │   ├── router/                      # Vue Router configuration
│   │   │   └── index.ts
│   │   ├── graphql/                     # GraphQL queries/mutations
│   │   │   ├── queries.ts
│   │   │   └── mutations.ts
│   │   ├── types/                       # TypeScript type definitions
│   │   │   └── generated.ts             # Auto-generated from GraphQL schema
│   │   └── App.vue
│   ├── public/                          # Static files (favicon, index.html template)
│   ├── package.json
│   ├── vite.config.ts
│   ├── tsconfig.json
│   └── tailwind.config.js
├── migrations/                           # MyBatis Migrations (database schema)
│   ├── scripts/
│   │   ├── 001_create_users_table.sql
│   │   ├── 002_create_calendars_table.sql
│   │   ├── 003_create_orders_table.sql
│   │   └── ...
│   └── environments/
│       ├── development.properties
│       └── production.properties
├── infrastructure/                       # Infrastructure as Code
│   ├── terraform/                       # Terraform configurations
│   │   ├── cloudflare/                  # Cloudflare resources (DNS, R2, tunnels)
│   │   └── aws/                         # AWS resources (SES, future)
│   ├── ansible/                         # Ansible playbooks
│   │   ├── deploy-k3s.yml              # Deploy to Kubernetes
│   │   └── setup-database.yml          # PostgreSQL setup
│   └── kubernetes/                      # Kubernetes manifests
│       ├── base/                        # Base configurations
│       │   ├── deployment.yaml
│       │   ├── service.yaml
│       │   └── hpa.yaml
│       ├── overlays/
│       │   ├── beta/                    # Beta environment
│       │   └── production/              # Production environment
│       └── secrets/                     # Secret templates (not committed)
│           └── secrets.example.yaml
├── docs/                                 # Documentation and design artifacts
│   ├── diagrams/                        # UML diagrams (PlantUML/Mermaid source)
│   │   ├── component_diagram.puml
│   │   ├── database_erd.puml
│   │   ├── deployment_diagram.puml
│   │   ├── sequence_oauth_login.puml
│   │   ├── sequence_order_placement.puml
│   │   └── sequence_pdf_generation.puml
│   ├── adr/                             # Architectural Decision Records (optional)
│   │   ├── 001-modular-monolith.md
│   │   ├── 002-graphql-primary-api.md
│   │   └── 003-async-job-pattern.md
│   └── guides/                          # Developer guides
│       ├── setup.md                     # Local development setup
│       ├── deployment.md                # Deployment guide
│       └── contributing.md              # Contribution guidelines
├── api/                                  # API specifications
│   ├── graphql-schema.graphql           # GraphQL schema definition
│   └── openapi-rest.yaml                # REST API spec (webhooks, downloads)
├── tests/                                # End-to-end tests
│   └── e2e/
│       └── cypress/                     # Cypress E2E tests (future)
├── .github/                              # GitHub Actions workflows
│   └── workflows/
│       ├── ci.yml                       # Continuous integration
│       └── deploy.yml                   # Continuous deployment
├── .codemachine/                         # Code generation artifacts
│   └── artifacts/
│       └── plan/                        # This project plan
├── pom.xml                               # Maven project configuration
├── Dockerfile                            # Docker image build
├── .dockerignore
├── .gitignore
├── README.md                             # Project overview
└── LICENSE
```

**Rationale for Key Structural Choices:**

1. **`src/main/java/.../` Domain-Based Packages**: Organize by technical layer (api, service, repository, model) rather than feature modules. Simpler for small team, easier navigation. Future refactoring into feature modules (e.g., `calendar/`, `commerce/`) if team grows.

2. **`frontend/` Separate Directory**: Clear frontend/backend separation. Quinoa plugin integrates Vue build into Quarkus at compile time (single deployment artifact).

3. **`migrations/` Root-Level**: MyBatis Migrations requires specific structure. Root-level placement makes it obvious where schema changes live.

4. **`infrastructure/` Centralized**: All IaC (Terraform, Ansible, Kubernetes) in one place. Clear separation from application code.

5. **`docs/diagrams/` PlantUML Source**: Version-control diagram source files (`.puml`), not just PNGs. Enable easy updates, diff tracking.

6. **`api/` Specifications**: Central location for API contracts (GraphQL schema, OpenAPI specs). Frontend auto-generates types from these.

7. **`tests/e2e/` Separate from Unit Tests**: E2E tests (Cypress, future) run against deployed environment, not part of Maven build. Separate directory clarifies scope.
