# Project Plan: Village Calendar

**Version:** 1.0
**Date:** 2025-10-16
**Generated By:** Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

---

<!-- anchor: verification-and-integration-strategy -->
## 5. Verification and Integration Strategy

<!-- anchor: testing-levels -->
### 5.1. Testing Levels

The Village Calendar project employs a multi-layered testing strategy to ensure quality at every level of the system:

**1. Unit Testing (Iteration-Specific)**

*   **Scope**: Individual classes, methods, and functions in isolation
*   **Tools**: JUnit 5 (backend), Vitest (frontend)
*   **Coverage Target**: 70%+ for service layer, repository layer, utility classes
*   **Frequency**: Run on every commit (CI pipeline)
*   **Examples**:
    *   Entity validation tests (JPA constraint validation)
    *   Service method tests (business logic, edge cases)
    *   Repository query tests (custom queries, filters)
    *   GraphQL resolver tests (authorization, error handling)
    *   Utility class tests (astronomical calculations, PDF rendering helpers)
*   **Iteration Integration**: Unit tests written alongside implementation in each iteration (I1.T13, I2.T2, I2.T3, I3.T2, I4.T2)

**2. Integration Testing (Iteration-Specific)**

*   **Scope**: Component interactions, API endpoints, database operations, external service integrations
*   **Tools**: Quarkus test framework with REST Assured, Testcontainers (PostgreSQL, Jaeger)
*   **Coverage Target**: 70%+ for API layer, integration points
*   **Frequency**: Run before merge to main branch
*   **Examples**:
    *   GraphQL API workflows (create calendar, place order, generate PDF)
    *   Database transaction tests (ACID compliance, rollback scenarios)
    *   Job queue processing (DelayedJob execution, retry logic)
    *   External service integration (Stripe webhook, OAuth callback, R2 upload)
*   **Iteration Integration**: Integration tests written at end of each iteration (I2.T10, I3.T9, I4.T10, I5.T10)

**3. End-to-End (E2E) Testing (Iteration 6)**

*   **Scope**: Complete user workflows through UI, simulating real user interactions
*   **Tools**: Cypress or Playwright
*   **Coverage**: Critical user journeys (guest calendar creation, checkout, admin workflows)
*   **Frequency**: Run after deployment to beta environment
*   **Examples**:
    *   Guest user creates calendar from template, adds events, saves to session
    *   User authenticates via OAuth, calendar transferred to account
    *   User places order, redirected to Stripe, payment succeeds, order confirmed
    *   Admin views orders, updates status, views analytics dashboard
*   **Iteration Integration**: E2E suite created in I6.T5, integrated into CI/CD pipeline

**4. Load Testing (Iteration 6)**

*   **Scope**: System performance under expected and peak traffic loads
*   **Tools**: JMeter or Gatling
*   **Scenarios**: Baseline (100 users), sustained (500 users, 1 hour), peak (2000 users), PDF generation (100 jobs)
*   **Frequency**: Before major releases, seasonal peak preparation (Q4)
*   **Metrics**: Throughput (req/sec), latency (p50, p95, p99), error rate, resource utilization (CPU, memory, database connections)
*   **Iteration Integration**: Load testing conducted in I6.T4 with performance validation

**5. Security Testing (Iteration 6)**

*   **Scope**: Vulnerability scanning, penetration testing, security control verification
*   **Tools**: OWASP ZAP (web app scanning), Snyk (dependency scanning), SonarQube (code analysis)
*   **Frequency**: Before production deployment, quarterly security audits
*   **Focus Areas**: SQL injection, XSS, CSRF, authentication bypass, insecure dependencies, secrets exposure
*   **Iteration Integration**: Security audit conducted in I6.T3 with remediation

**6. Acceptance Testing (Continuous)**

*   **Scope**: Business requirement validation, user story acceptance
*   **Approach**: Manual testing by product owner, stakeholders
*   **Frequency**: End of each iteration (demo/review)
*   **Criteria**: Acceptance criteria defined in each task (see task definitions)
*   **Sign-off**: Required before moving to next iteration

---

<!-- anchor: ci-cd-pipeline -->
### 5.2. CI/CD Pipeline

**Continuous Integration (CI) - Triggered on Every Push/Pull Request**

1.  **Checkout Code**: Clone repository
2.  **Backend Build**:
    *   Maven compile (`./mvnw compile`)
    *   Run unit tests (`./mvnw test`)
    *   JaCoCo coverage report (fail if <70% for service/API layers)
    *   Security scanning (Snyk dependency check, OWASP dependency check)
    *   SonarQube analysis (code quality, security hotspots)
3.  **Frontend Build**:
    *   npm install
    *   ESLint linting (`npm run lint`)
    *   Vite production build (`npm run build`)
    *   (Optional) Vitest unit tests (`npm run test`)
4.  **Integration Tests**:
    *   Run Quarkus integration tests (`./mvnw verify`)
    *   Use Testcontainers for PostgreSQL, Jaeger
5.  **Docker Build**:
    *   Build Docker image (`docker build -t villagecompute/calendar-api:${GIT_SHA}`)
    *   (Optional) Scan image for vulnerabilities (Trivy, Snyk Container)
6.  **Publish Artifact**:
    *   Push Docker image to Docker Hub with tags: `${GIT_SHA}`, `latest` (for main branch)

**Continuous Deployment (CD) - Beta Environment**

*   **Trigger**: Merge to `beta` branch
*   **Steps**:
    1.  Run CI pipeline (above)
    2.  Connect to k3s cluster via WireGuard VPN
    3.  Update Kubernetes deployment in `calendar-beta` namespace:
        *   `kubectl set image deployment/calendar-api calendar-api=villagecompute/calendar-api:${GIT_SHA} -n calendar-beta`
    4.  Wait for rollout completion (`kubectl rollout status deployment/calendar-api -n calendar-beta`)
    5.  Run smoke tests:
        *   Health check (`curl http://calendar-beta.villagecompute.com/q/health/ready`)
        *   Sample GraphQL query (fetch templates)
    6.  Run E2E tests (Cypress suite against beta environment)
    7.  Notify Slack channel (#deploy-alerts) on success/failure

**Continuous Deployment (CD) - Production Environment**

*   **Trigger**: Merge to `main` branch + manual approval
*   **Steps**:
    1.  Run CI pipeline (above)
    2.  Wait for manual approval (GitHub environment protection: "production")
    3.  Pre-deployment checks:
        *   Verify database migrations backward compatible
        *   Review changelog/release notes
    4.  Connect to k3s cluster via WireGuard VPN
    5.  Apply Kubernetes manifests (Kustomize overlay for production):
        *   `kubectl apply -k infrastructure/kubernetes/overlays/production/`
    6.  Canary deployment strategy:
        *   Deploy 1 pod, wait 5 minutes, monitor metrics
        *   Scale to 50% (5 pods if current is 10), wait 10 minutes
        *   Scale to 100% (full rollout)
    7.  Run extensive smoke tests:
        *   Health check
        *   GraphQL query (calendar, order)
        *   Place test order (use Stripe test mode or dedicated test account)
    8.  Notify team on completion (Slack, email)
    9.  Monitor for 1 hour post-deployment (error rate, latency, alerts)

**Rollback Procedure**

*   **Trigger**: Smoke tests fail, error rate >5%, critical bug reported
*   **Steps**:
    1.  `kubectl rollout undo deployment/calendar-api -n calendar-prod`
    2.  Verify rollback success (health check, smoke tests)
    3.  Notify team of rollback
    4.  Investigate root cause, fix in `main` branch, re-deploy

---

<!-- anchor: code-quality-gates -->
### 5.3. Code Quality Gates

**Mandatory Gates (CI Pipeline Fails If Not Met)**

1.  **Compilation Success**: Backend and frontend must compile without errors
2.  **Unit Test Pass**: All unit tests must pass (0% failure tolerance)
3.  **Code Coverage**: Minimum 70% line coverage for service layer, API layer, repository layer (JaCoCo enforcement)
4.  **Linting**: ESLint must pass with 0 errors (warnings allowed, but discouraged)
5.  **Security Scan**: No critical severity vulnerabilities in dependencies (Snyk/OWASP)
6.  **Integration Test Pass**: All integration tests must pass

**Advisory Gates (Warnings, Manual Review Required)**

1.  **Code Coverage <80%**: Warning if coverage below 80% (target is 70%, stretch goal 80%)
2.  **SonarQube Security Hotspots**: Security hotspots flagged for review (not blocking, but should be addressed)
3.  **Dependency Vulnerabilities (Medium Severity)**: Medium severity vulnerabilities logged, should be addressed in next sprint
4.  **Code Duplication >5%**: SonarQube detects code duplication exceeding 5% (refactoring recommended)

**Pre-Production Gates (Additional Checks Before Production Deployment)**

1.  **Load Testing**: Performance targets met (p95 latency <500ms, throughput >100 req/sec)
2.  **E2E Testing**: All E2E tests pass against beta environment
3.  **Security Audit**: OWASP ZAP scan shows no high/critical vulnerabilities
4.  **Manual Smoke Testing**: Product owner/QA signs off on beta environment
5.  **Database Migration Safety**: Migrations reviewed for backward compatibility

---

<!-- anchor: artifact-validation -->
### 5.4. Artifact Validation

**Architectural Diagrams (PlantUML)**

*   **Syntax Validation**: PlantUML files must render without syntax errors
    *   Tool: PlantUML CLI (`plantuml -syntax <file>.puml`)
    *   Frequency: On commit (CI pipeline can validate)
*   **Content Review**: Diagrams reviewed for accuracy against architecture plan
    *   Reviewer: Tech lead or architect
    *   Frequency: End of iteration (when diagram created/updated)
*   **Version Control**: Diagram source files (`.puml`) committed to Git, PNG exports for documentation

**GraphQL Schema**

*   **Syntax Validation**: Schema must parse without errors
    *   Tool: GraphQL schema validator (`graphql-schema-linter` or SmallRye GraphQL compile-time check)
    *   Frequency: On commit (CI pipeline)
*   **Breaking Change Detection**: Schema changes reviewed for backward compatibility
    *   Process: Manual review during PR, check for removed/renamed fields
    *   Action: Deprecate fields before removal (grace period: 6 months)
*   **Type Generation**: TypeScript types auto-generated from schema for frontend
    *   Tool: GraphQL Code Generator
    *   Frequency: On schema change (pre-commit hook or CI job)

**Database Migration Scripts**

*   **Syntax Validation**: SQL scripts must execute without errors on test database
    *   Tool: MyBatis Migrations `migrate up` on test database
    *   Frequency: Integration test suite (I1.T7 acceptance criteria)
*   **Backward Compatibility**: Migrations reviewed for safety (no column drops, nullable new columns, defaults provided)
    *   Reviewer: Database admin or tech lead
    *   Frequency: Before production deployment
*   **Rollback Testing**: Down migrations tested on staging environment (for development rollback scenarios)
    *   Note: Production uses forward-only migrations (rollback via new migration)

**OpenAPI Specifications (If Created)**

*   **Syntax Validation**: OpenAPI spec validates against OpenAPI 3.0 schema
    *   Tool: `swagger-cli validate <spec>.yaml`
    *   Frequency: On commit
*   **Content Review**: API endpoints match implementation
    *   Process: Manual review, automated tests can verify endpoints exist

**Documentation (Markdown)**

*   **Link Validation**: All internal links in documentation resolve correctly
    *   Tool: `markdown-link-check` or similar
    *   Frequency: Weekly automated check or on commit
*   **Content Review**: Documentation reviewed for clarity, accuracy, completeness
    *   Reviewer: Technical writer, developer, product owner
    *   Frequency: End of iteration, major releases
*   **Screenshot Currency**: Screenshots updated when UI changes significantly
    *   Process: Manual review, annotate screenshots with version/date

---

<!-- anchor: integration-strategy -->
### 5.5. Integration Strategy

**Incremental Integration Approach**

Village Calendar follows an **incremental, iteration-based integration** strategy:

1.  **Iteration-Level Integration**: Each iteration delivers a cohesive set of features that integrate with previous iterations.
    *   Example: Iteration 2 (calendar functionality) integrates with Iteration 1 (database, authentication).
    *   Integration tests at end of each iteration verify cross-iteration compatibility.

2.  **Feature Branch Integration**: Developers work on feature branches, integrate frequently via pull requests to `main`.
    *   PR merges trigger CI pipeline (unit tests, integration tests, code review).
    *   Small, frequent merges reduce integration complexity.

3.  **Continuous Integration to Beta**: All changes merged to `main` automatically deploy to beta environment.
    *   Beta environment is the primary integration testing ground.
    *   E2E tests run against beta to catch integration issues early.

4.  **Staged Rollout to Production**: Production deployments use canary strategy to minimize risk.
    *   1 pod → 50% → 100% allows for early detection of integration issues with real traffic.

**Dependency Management**

*   **Task Dependencies**: Explicitly defined in iteration plan (see "Dependencies" field in each task).
    *   Sequential dependencies: Task B cannot start until Task A completes.
    *   Parallelizable tasks: Can execute concurrently to maximize throughput.
*   **Service Dependencies**: External services (Stripe, OAuth, R2) integrated via client libraries with circuit breakers.
    *   Failures in external services degrade gracefully (queued operations, user-friendly errors).
*   **Database Dependencies**: Shared database ensures transactional consistency.
    *   Schema migrations coordinated with application deployments (backward-compatible changes).

**Environment Promotion**

*   **Development** → **Beta** → **Production**
*   **Development**: Local developer machines, in-memory database (H2) or local PostgreSQL
*   **Beta**: `calendar-beta.villagecompute.com`, k3s namespace `calendar-beta`, separate database
    *   Continuous deployment from `beta` branch
    *   Integration and E2E testing ground
*   **Production**: `calendar.villagecompute.com`, k3s namespace `calendar-prod`, production database
    *   Manual approval required for deployment
    *   Canary rollout strategy
    *   Post-deployment monitoring (1 hour)

---

<!-- anchor: glossary -->
## 6. Glossary

**Term** | **Definition**
---------|---------------
**Active Record Pattern** | ORM pattern where entity classes include data access methods (used by Panache).
**ADR (Architectural Decision Record)** | Document capturing important architectural decisions and their rationale.
**API Gateway** | Entry point for API requests, handles routing, authentication, rate limiting (Cloudflare Tunnel acts as ingress).
**Batik** | Apache XML graphics library for SVG to PDF rendering.
**C4 Model** | Context, Containers, Components, Code - hierarchical architectural diagram framework.
**CDN (Content Delivery Network)** | Globally distributed cache servers for static assets (Cloudflare CDN).
**Circuit Breaker** | Fault tolerance pattern preventing cascading failures by fast-failing when error threshold exceeded.
**CORS (Cross-Origin Resource Sharing)** | HTTP header mechanism allowing web apps to request resources from different domains.
**CSRF (Cross-Site Request Forgery)** | Attack tricking user's browser into unauthorized requests; prevented via token validation.
**DataLoader** | GraphQL pattern batching and caching queries to prevent N+1 problem.
**DelayedJob** | Asynchronous job processing pattern with database-backed queue and worker polling.
**ERD (Entity Relationship Diagram)** | Visual representation of database schema showing entities and relationships.
**EventBus** | Vert.x component for publish-subscribe messaging between application components.
**GraphQL** | Query language enabling clients to request exactly the data needed, reducing over-fetching.
**HPA (Horizontal Pod Autoscaler)** | Kubernetes component scaling pods based on CPU, memory, or custom metrics.
**JDBC (Java Database Connectivity)** | Java API for database connections and SQL execution.
**JWT (JSON Web Token)** | Compact, self-contained token for securely transmitting authentication/authorization claims.
**K3s** | Lightweight Kubernetes distribution optimized for resource-constrained environments.
**Kubernetes** | Container orchestration platform automating deployment, scaling, and management.
**MyBatis Migrations** | Database schema migration tool with versioned SQL scripts.
**OAuth 2.0** | Industry-standard authorization framework for delegating access to user resources.
**OIDC (OpenID Connect)** | Identity layer on OAuth 2.0 for authentication, returns user profile info.
**Panache** | Quarkus extension simplifying Hibernate ORM with active record pattern and repository pattern.
**PCI DSS** | Payment Card Industry Data Security Standard - compliance requirements for payment processing.
**PDF** | Portable Document Format - file format for print-ready documents.
**PlantUML** | Text-based UML diagram tool supporting component, sequence, ERD diagrams.
**PostgreSQL** | Open-source relational database with ACID compliance, JSONB support, PostGIS extension.
**PostGIS** | PostgreSQL extension adding geospatial data types and functions.
**Prometheus** | Open-source monitoring system with time-series database and alerting.
**Quarkus** | Java framework optimized for cloud-native, containerized applications with fast startup.
**Quinoa** | Quarkus plugin integrating Node.js frontend builds (Vue/React/Angular) into single deployment artifact.
**R2** | Cloudflare's S3-compatible object storage service with global edge distribution.
**RBAC (Role-Based Access Control)** | Access control model assigning permissions based on user roles (user, admin).
**REST (Representational State Transfer)** | Architectural style for web APIs using HTTP methods (GET, POST, PUT, DELETE).
**RPO (Recovery Point Objective)** | Maximum acceptable data loss duration in disaster recovery (e.g., 24 hours).
**RTO (Recovery Time Objective)** | Maximum acceptable downtime duration in disaster recovery (e.g., 4 hours).
**SDL (Schema Definition Language)** | GraphQL language for defining types, queries, mutations in `.graphql` files.
**SLA (Service Level Agreement)** | Commitment to uptime and performance level (e.g., 99.5% uptime).
**SMTP (Simple Mail Transfer Protocol)** | Internet protocol for email transmission.
**SPA (Single-Page Application)** | Web app loading single HTML page, dynamically updating content without page reloads.
**Stripe** | Payment processing platform handling credit cards, subscriptions, refunds with PCI compliance.
**SVG (Scalable Vector Graphics)** | XML-based vector image format, rendered to PDF via Batik.
**Testcontainers** | Java library providing disposable Docker containers for integration testing (PostgreSQL, Jaeger).
**TLS (Transport Layer Security)** | Cryptographic protocol securing HTTPS communications.
**Vert.x** | Reactive toolkit for building event-driven applications on JVM (EventBus, async I/O).
**Vue Router** | Official routing library for Vue.js enabling client-side navigation.
**WAF (Web Application Firewall)** | Filters and monitors HTTP traffic to protect against attacks (Cloudflare WAF).
**Webhook** | HTTP callback triggered by external event (e.g., Stripe payment success).
**XSS (Cross-Site Scripting)** | Injection attack executing malicious scripts in user's browser; prevented via output encoding.

---

<!-- anchor: iteration-dependencies -->
## 7. Iteration Dependencies Summary

**Dependency Graph:**

```
I1 (Foundation)
 ├─→ I2 (Calendar Functionality)
 │    ├─→ I4 (PDF Generation)
 │    └─→ I5 (Analytics & Observability)
 ├─→ I3 (E-Commerce)
 │    └─→ I5 (Analytics & Observability)
 └─→ I6 (Deployment & Launch)

I2, I3, I4, I5 → I6 (All core features must be complete before launch preparation)
```

**Iteration Dependency Table:**

| Iteration | Prerequisites | Can Start After | Parallel With | Blocks |
|-----------|---------------|-----------------|---------------|--------|
| I1 | None | Immediately | None | I2, I3, I6 |
| I2 | I1 (Database, Auth) | I1 complete | None | I4, I5, I6 |
| I3 | I1 (Database, Auth) | I1 complete | I2 (partially) | I5, I6 |
| I4 | I2 (Calendar data) | I2 complete | I3, I5 | I6 |
| I5 | I2 (Calendar), I3 (Orders) | I2, I3 complete | I4 | I6 |
| I6 | I1-I5 (All features) | All complete | None | None (Launch) |

**Critical Path:**

I1 → I2 → I4 → I6 (longest dependency chain)

**Estimated Total Duration:**

*   I1: 2-3 weeks
*   I2: 3-4 weeks (starts after I1)
*   I3: 3-4 weeks (starts after I1, parallel with I2 partially)
*   I4: 3-4 weeks (starts after I2)
*   I5: 2-3 weeks (starts after I2 and I3)
*   I6: 2-3 weeks (starts after all)

**Total Sequential**: ~15-21 weeks (3.5-5 months)

**With Parallelization**: ~12-18 weeks (3-4.5 months) - I3 can overlap with I2 (backend auth/user features independent), I5 can partially overlap with I4

**Realistic Estimate with Buffer**: **16-20 weeks (4-5 months)** for MVP launch, accounting for:
*   Task overruns (complex features take longer than estimated)
*   Bug fixing and rework (integration issues, failed tests)
*   Review and approval cycles (code reviews, architecture decisions)
*   External dependencies (OAuth approval, Stripe verification, infrastructure setup delays)

---

## Conclusion

This comprehensive project plan provides a structured, iterative roadmap for developing the Village Calendar MVP. The plan balances technical rigor with practical delivery timelines, emphasizing:

1.  **Incremental Value**: Each iteration delivers working features, enabling early feedback and course correction.
2.  **Quality Assurance**: Multi-layered testing strategy (unit, integration, E2E, load, security) ensures robustness.
3.  **Risk Mitigation**: Identified risks with mitigation strategies, deployment rollback procedures, canary releases.
4.  **Scalability**: Architecture designed for horizontal scaling (stateless pods, async jobs, CDN caching).
5.  **Observability**: Comprehensive monitoring (Jaeger, Prometheus, health checks) for operational excellence.
6.  **Documentation**: Extensive guides for developers, admins, and end users, ensuring knowledge transfer and self-service support.

**Success Criteria for MVP Launch:**

- All 6 iterations completed with acceptance criteria met
- Security audit passed (no critical vulnerabilities)
- Load testing validated performance targets (p95 <500ms, 99.5% uptime)
- E2E tests passing (critical user workflows functional)
- Production deployment successful with monitoring active
- User documentation published (help center, legal pages)
- Launch checklist 100% complete

**Next Steps After Plan Approval:**

1.  Review and approve architectural blueprint and iteration plan with stakeholders
2.  Provision infrastructure (k3s cluster, PostgreSQL, Cloudflare resources)
3.  Kick off Iteration 1 (assign tasks to developers, begin implementation)
4.  Establish weekly iteration reviews (demo completed features, adjust plan as needed)
5.  Execute iterations sequentially with parallelization where feasible
6.  Conduct launch readiness review before final deployment

The plan is designed to be **adaptive** - iterations can be adjusted based on learnings, and the modular architecture allows for feature scope changes without major rework. The team should treat this plan as a living document, updating it as the project progresses.
