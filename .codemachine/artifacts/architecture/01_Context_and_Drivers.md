# System Architecture Blueprint: Village Calendar

**Version:** 1.0
**Date:** 2025-10-16
**Generated By:** Claude Sonnet 4.5

---

<!-- anchor: introduction-and-goals -->
## 1. Introduction & Goals

<!-- anchor: project-vision -->
### 1.1. Project Vision

Village Calendar is a full-stack web application that empowers users to create, customize, and order professional-quality full-year calendars. The platform combines an intuitive browser-based calendar editor with sophisticated astronomical calculations (moon phases, Hebrew calendar integration) and a complete e-commerce fulfillment pipeline. Users can design calendars with custom events, emojis, holiday sets, and astronomical overlays, then either download high-resolution PDFs or order physical printed versions delivered to their door.

The system serves both individual consumers seeking personalized calendars and potential business customers requiring bulk orders, while providing administrators with comprehensive tools for template management, order fulfillment, and business analytics.

<!-- anchor: key-objectives -->
### 1.2. Key Objectives

**Functional Objectives:**
- Enable anonymous users to create and preview custom calendars without authentication
- Support user authentication via OAuth (Google, Facebook, Apple) for saving and managing calendars
- Provide a rich calendar editor with real-time preview, astronomical data integration, and template system
- Generate high-fidelity PDF exports suitable for both digital download and professional printing
- Process physical product orders through Stripe payment integration with full order lifecycle management
- Deliver administrative interfaces for template creation, order management, and business analytics
- Implement asynchronous job processing for resource-intensive operations (PDF generation, email sending)

**Non-Functional Objectives:**
- **Scalability**: Handle seasonal demand spikes (November-January) with horizontal scaling capabilities
- **Performance**: Generate calendar previews in <2 seconds, full PDFs in <30 seconds
- **Availability**: Target 99.5% uptime with automated health monitoring and recovery
- **Security**: Implement OAuth 2.0 authentication, HTTPS everywhere, CSRF protection, input sanitization, and secure payment processing
- **Maintainability**: Leverage existing Quarkus + Vue.js stack for consistency with team expertise
- **Usability**: Provide seamless guest-to-authenticated user conversion with session persistence
- **Observability**: Comprehensive distributed tracing (Jaeger), metrics (Prometheus), and health checks

<!-- anchor: scope -->
### 1.3. Scope

**In Scope:**
- Full-stack web application (backend API + frontend SPA)
- Calendar editor with template system and astronomical calculations
- User authentication and account management (OAuth providers)
- PDF generation pipeline with watermarking for free tier
- E-commerce integration (Stripe checkout, order management, basic shipping workflows)
- Administrative dashboard (template management, order processing, analytics)
- Asynchronous job processing system (DelayedJob pattern)
- Email notification system (order confirmations, shipping updates)
- Database schema for users, calendars, orders, templates, analytics
- Basic SEO optimization for public pages
- Infrastructure deployment on Kubernetes with Cloudflare CDN

**Out of Scope (Phase 1/MVP):**
- Mobile native applications (iOS/Android)
- Advanced collaboration features (shared editing, comments)
- Subscription-based recurring calendar service
- White-label solutions for third-party businesses
- Full shipping provider API integration (ShipStation/EasyPost) - manual label generation for MVP
- Internationalization/localization beyond English
- AI-powered event suggestions
- Public calendar gallery and user-generated content showcase
- Referral program implementation
- Advanced A/B testing framework
- Native integrations with Google Calendar/iCal

<!-- anchor: key-assumptions -->
### 1.4. Key Assumptions

**Technical Assumptions:**
- The existing Quarkus 3.26.2 + Vue 3.5 stack is stable and team has expertise
- PostgreSQL 17+ with PostGIS extensions can handle astronomical calculation storage
- Current DelayedJob implementation pattern is proven and can be extended
- Batik SVG rendering library provides sufficient quality for PDF generation
- Existing Kubernetes (k3s) infrastructure can scale to handle initial user load
- Cloudflare R2 provides sufficient storage for user-generated calendars and PDFs

**Business Assumptions:**
- Initial user base will be B2C individual consumers (not B2B focus for MVP)
- Seasonal demand will peak in Q4 (November-January) requiring 3-5x normal capacity
- Print-on-demand partner model is preferred over in-house printing for MVP
- Free tier will use watermarked PDFs to drive conversion to paid downloads
- Stripe supports all required payment methods for target market (US-focused initially)
- Marketing acquisition will primarily be organic SEO and content marketing for MVP
- Order fulfillment SLA of 3-5 business days is acceptable for standard orders

**Environmental Assumptions:**
- GitHub Actions CI/CD pipeline with WireGuard VPN to Proxmox k3s is operational
- Cloudflare Tunnel provides secure ingress without exposing infrastructure
- GoogleWorkspace SMTP is sufficient for transactional email volume (<10k/month initially)
- Terraform state management (S3 + DynamoDB) is properly configured
- Development team has access to required AWS services (SES if switching from Google SMTP)

**User Behavior Assumptions:**
- Majority of users will start as anonymous guests before converting to authenticated users
- Calendar creation sessions may span multiple days (require session persistence)
- Users expect real-time preview updates as they modify calendar settings
- Average calendar will have 10-50 custom events with 1-3 emoji/icon selections
- Bulk orders (5+ calendars) will be <20% of total orders initially
- Users will primarily access via desktop browsers (mobile-responsive but not mobile-first)

---

<!-- anchor: architectural-drivers -->
## 2. Architectural Drivers

<!-- anchor: functional-requirements-summary -->
### 2.1. Functional Requirements Summary

**Core User Workflows:**

1. **Calendar Creation & Editing**
   - Anonymous users create calendars without authentication (session-based persistence)
   - Select from pre-built templates or start from blank canvas
   - Add custom events (dates, text, emojis)
   - Configure holiday sets (US, religious, cultural)
   - Enable astronomical overlays (moon phases, Hebrew calendar dates)
   - Real-time preview with print-safe area indicators

2. **User Authentication & Account Management**
   - OAuth 2.0 integration (Google, Facebook, Apple)
   - Convert guest sessions to authenticated accounts on login
   - Manage multiple saved calendars per user
   - View order history and tracking information
   - Update profile and shipping addresses

3. **PDF Generation & Downloads**
   - Asynchronous high-resolution PDF generation (36" x 23" print-ready)
   - Watermarked PDFs for free tier
   - Premium unwatermarked downloads (paid)
   - Calendar preview image generation for thumbnails
   - Progress indicators for long-running jobs

4. **E-Commerce & Order Processing**
   - Stripe Checkout integration for secure payments
   - Single calendar orders with shipping calculations
   - Order status tracking (Pending → Production → Shipped → Delivered)
   - Email notifications at each lifecycle stage
   - Refund/cancellation handling

5. **Administrative Operations**
   - Create and manage calendar templates (same UI as user editor + "Save as Template")
   - Order management dashboard (filter, search, bulk operations)
   - Mark orders as shipped with tracking numbers
   - View business analytics (revenue, conversion funnels, popular templates)
   - User account management (for support escalations)

6. **Asynchronous Job Processing**
   - PDF rendering jobs with priority queues
   - Email sending (transactional notifications)
   - Analytics aggregation and rollup
   - Retry logic with exponential backoff for failures
   - Job status monitoring and failure alerts

<!-- anchor: non-functional-requirements -->
### 2.2. Non-Functional Requirements (NFRs)

<!-- anchor: nfr-performance -->
#### 2.2.1. Performance

**Requirements:**
- Calendar preview generation: <2 seconds for typical calendar (50 events)
- Full PDF generation: <30 seconds for standard size (36" x 23")
- API response times: p95 <500ms for synchronous endpoints
- Page load times: <3 seconds for authenticated users, <2 seconds for static landing pages
- Database query performance: <100ms for p95 of user-facing queries

**Architectural Impact:**
- Asynchronous job processing for heavy operations (PDF generation, email bulk sends)
- Caching layer for calendar previews (Cloudflare CDN + R2 storage)
- Database indexing strategy on high-query columns (user_id, order_id, created_at, status)
- Connection pooling for PostgreSQL (HikariCP via Quarkus)
- Stateless API services to enable horizontal scaling

<!-- anchor: nfr-scalability -->
#### 2.2.2. Scalability

**Requirements:**
- Support 3-5x seasonal traffic spike (November-January)
- Handle 10,000+ concurrent anonymous sessions
- Process 1,000+ PDF generation jobs in queue during peak
- Scale from 100 orders/day (baseline) to 500+ orders/day (holiday peak)

**Architectural Impact:**
- Kubernetes horizontal pod autoscaling (HPA) for API and worker pods
- Stateless application design (session data in database/Redis, not in-memory)
- DelayedJob queue with multiple workers for parallel processing
- CDN offloading for static assets and public calendar previews
- Database read replicas for analytics queries (future consideration)

<!-- anchor: nfr-availability -->
#### 2.2.3. Availability & Reliability

**Requirements:**
- Target uptime: 99.5% (approximately 3.5 hours downtime/month acceptable)
- Graceful degradation: Read-only mode if database issues, queued writes when recovered
- Zero-downtime deployments via Kubernetes rolling updates
- Automated health checks and pod restarts

**Architectural Impact:**
- SmallRye Health endpoints for Kubernetes liveness/readiness probes
- Database connection retry logic with circuit breakers
- Distributed tracing to identify failure points (Jaeger)
- Automated backups (daily PostgreSQL dumps, 30-day retention)
- Multi-zone Kubernetes node distribution (if infrastructure supports)

<!-- anchor: nfr-security -->
#### 2.2.4. Security

**Requirements:**
- PCI DSS compliance for payment processing (delegated to Stripe)
- OAuth 2.0 / OIDC for user authentication
- HTTPS everywhere (TLS 1.2+ via Cloudflare)
- CSRF protection on state-changing operations
- Input validation and sanitization (prevent XSS, SQL injection)
- Secrets management (database credentials, OAuth client secrets, Stripe API keys)
- Rate limiting on public endpoints (prevent DoS)
- Content Security Policy (CSP) headers
- Regular dependency scanning for vulnerabilities

**Architectural Impact:**
- Quarkus OIDC extension for OAuth integration
- Quarkus REST CSRF protection
- Hibernate ORM parameterized queries (prevent SQL injection)
- Vue.js automatic XSS escaping in templates
- Environment variable injection for secrets (Kubernetes secrets)
- SmallRye Fault Tolerance for rate limiting
- Cloudflare DDoS protection and WAF rules

<!-- anchor: nfr-maintainability -->
#### 2.2.5. Maintainability & Extensibility

**Requirements:**
- Clear separation of concerns (UI, business logic, data access)
- Consistent coding patterns across features
- Comprehensive logging for debugging production issues
- Automated testing coverage (target 70%+ for critical paths)
- API versioning strategy for backward compatibility
- Database migration tooling (MyBatis Migrations already in use)

**Architectural Impact:**
- Layered architecture with Panache repositories, service layer, REST controllers
- GraphQL schema evolution without breaking existing clients
- Centralized logging (structured JSON logs) aggregated in observability stack
- OpenTelemetry instrumentation for distributed tracing
- API documentation via GraphQL introspection
- Feature flags for gradual rollout of new capabilities (future)

<!-- anchor: nfr-usability -->
#### 2.2.6. Usability

**Requirements:**
- Intuitive calendar editor requiring minimal onboarding
- Seamless guest-to-authenticated user conversion (preserve session data)
- Mobile-responsive design (primary focus: desktop, but functional on tablets/phones)
- Accessible UI (WCAG 2.1 AA target for public pages)
- Real-time feedback on user actions (save confirmations, validation errors)

**Architectural Impact:**
- Vue 3 Composition API for reactive UI components
- PrimeVue UI library for consistent design system
- LocalStorage + database sync for session persistence
- Optimistic UI updates with background API calls
- Form validation both client-side (Vue) and server-side (Quarkus)

<!-- anchor: nfr-observability -->
#### 2.2.7. Observability

**Requirements:**
- Distributed request tracing across services and database calls
- Business metrics dashboards (orders, revenue, conversion rates)
- Application performance monitoring (APM)
- Error tracking and alerting
- Job queue monitoring (queue depth, processing times, failures)

**Architectural Impact:**
- OpenTelemetry instrumentation in Quarkus
- Jaeger for trace visualization
- Prometheus metrics export from Quarkus
- Custom metrics for business KPIs (order_placed, pdf_generated, etc.)
- Grafana dashboards for visualization
- Alert rules for critical failures (payment processing, job queue backlog)

<!-- anchor: constraints-and-preferences -->
### 2.3. Constraints & Preferences

<!-- anchor: technological-constraints -->
#### 2.3.1. Technological Constraints

**Mandated Technologies (from existing stack):**
- **Backend Framework**: Quarkus 3.26.2 (Java 21) - Team expertise, existing infrastructure
- **ORM**: Hibernate ORM with Panache - Active record pattern simplifies data access
- **Database**: PostgreSQL 17+ with PostGIS - Required for astronomical calculations, geospatial queries
- **Frontend Framework**: Vue 3.5+ with Composition API - Team expertise, reactive performance
- **UI Library**: PrimeVue 4.2+ (Aura theme) - Consistent design system, accessibility support
- **Build Tool**: Vite 6.1+ with Quinoa plugin - Fast HMR, seamless Quarkus integration
- **Infrastructure**: Kubernetes (k3s on Proxmox) - Existing deployment pipeline
- **CDN/DNS**: Cloudflare - Existing account, DDoS protection, tunnel ingress
- **Database Migrations**: MyBatis Migrations - Already configured in migrations module

**Preferred Technologies (strong preference unless justified otherwise):**
- **GraphQL**: SmallRye GraphQL for flexible frontend data fetching
- **Async Processing**: Existing DelayedJob pattern + Vert.x EventBus
- **Observability**: OpenTelemetry → Jaeger (traces) + Prometheus (metrics)
- **Payment Processing**: Stripe (industry standard, PCI compliance delegation)
- **Object Storage**: Cloudflare R2 (S3-compatible, cost-effective)
- **Email**: GoogleWorkspace SMTP (low volume), migrate to AWS SES if volume increases

<!-- anchor: organizational-constraints -->
#### 2.3.2. Organizational Constraints

**Development Team:**
- Small team with Java/Quarkus and Vue.js expertise
- Limited DevOps resources (rely on Infrastructure as Code - Terraform, Ansible)
- Preference for managed services over custom infrastructure components

**Infrastructure:**
- Self-hosted Kubernetes (k3s) on Proxmox for cost optimization
- Cloudflare for edge services (CDN, DNS, WAF, tunneling)
- Hybrid cloud approach (k3s for compute, Cloudflare R2 for storage)
- WireGuard VPN for secure CI/CD access to k3s cluster

**Budget:**
- Optimize for low operational costs during MVP phase
- Prefer open-source tooling (Quarkus, PostgreSQL, Jaeger, Prometheus)
- Accept managed service costs where they reduce operational burden (Stripe, Cloudflare)
- Plan for scaling costs aligned with revenue growth (Stripe fees are % of sales)

<!-- anchor: business-constraints -->
#### 2.3.3. Business Constraints

**Time to Market:**
- MVP launch target: 3-4 months from architecture approval
- Phased rollout: Core calendar editor → E-commerce → Advanced admin features
- Must launch before Q4 holiday season to capture peak demand

**Compliance:**
- GDPR compliance for EU users (data access, deletion, portability rights)
- CCPA compliance for California users (data disclosure, opt-out)
- PCI DSS for payment processing (delegated to Stripe Checkout)
- Email compliance (CAN-SPAM, GDPR email consent)

**Integration Requirements:**
- OAuth providers must support Google, Facebook, Apple (industry standard identity)
- Payment gateway must support major credit cards, Apple Pay, Google Pay (Stripe provides all)
- Email service must handle bounce tracking and unsubscribe management
- Shipping provider integration deferred to Phase 2 (manual label generation for MVP)

<!-- anchor: design-preferences -->
#### 2.3.4. Design Preferences

**Architectural Patterns:**
- **Modular Monolith** over microservices for MVP (simpler operations, faster development)
- **Active Record Pattern** (Panache) for straightforward CRUD operations
- **Repository Pattern** for complex queries and data access abstraction
- **Service Layer** for business logic separation from HTTP controllers
- **Async Job Pattern** for long-running, retriable operations

**Data Management:**
- **Single Source of Truth**: PostgreSQL as primary data store
- **Event Sourcing**: Not required for MVP, but DelayedJob events provide audit trail
- **Caching**: Pragmatic caching (CDN for static assets, consider Redis for hot data in Phase 2)

**API Design:**
- **GraphQL-first** for frontend flexibility (reduces over-fetching, under-fetching)
- **REST fallback** for webhooks (Stripe webhooks, future integrations)
- **API versioning**: Not critical for MVP (internal API), but design for evolution

**Frontend Architecture:**
- **Component-based**: Vue SFC (Single File Components) with Composition API
- **State Management**: Pinia for global state (user session, cart), component state for local UI
- **Routing**: Vue Router with lazy-loaded routes for code splitting
- **Form Handling**: Vuelidate or VeeValidate for validation, PrimeVue form components
