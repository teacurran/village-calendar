[
  {
    "task_id": "I2.T1",
    "iteration_id": "I2",
    "iteration_goal": "Implement calendar creation, editing, and template system. Build calendar editor UI components. Integrate astronomical calculations (moon phases, Hebrew calendar). Create sequence diagrams for key workflows",
    "description": "Create three PlantUML sequence diagrams documenting critical interaction flows: (1) OAuth Login Flow - showing user authentication via Google/Facebook/Apple, token exchange, user creation/retrieval, JWT token generation; (2) Order Placement Flow - showing cart checkout, Stripe Checkout session creation, payment webhook processing, order status updates, email job enqueueing; (3) PDF Generation Flow - showing async job workflow, calendar data retrieval, Batik rendering, R2 upload, status polling. Each diagram must include all actors (User, Vue SPA, Quarkus API, external services, database), show message sequences with proper timing, include error scenarios (alt/opt blocks), and follow PlantUML sequence diagram best practices.",
    "agent_type_hint": "DiagrammingAgent",
    "inputs": "Sequence diagram descriptions from Plan Section 3.7.3 \"Key Interaction Flows\", OAuth authentication architecture from Plan Section 3.8.1, Order placement workflow from Plan Section 3.7.3 Flow 2, PDF generation workflow from Plan Section 3.7.3 Flow 3",
    "target_files": ["docs/diagrams/sequence_oauth_login.puml", "docs/diagrams/sequence_order_placement.puml", "docs/diagrams/sequence_pdf_generation.puml"],
    "input_files": [],
    "deliverables": "Three PlantUML sequence diagram files rendering correctly, PNG exports of all diagrams for documentation, Diagrams accurately reflect workflows described in architecture plan, Error handling scenarios included (alt blocks for failures)",
    "acceptance_criteria": "All three PlantUML files validate and render without errors, OAuth login diagram shows complete flow from user click to JWT token response, Order placement diagram includes Stripe webhook validation and async email job, PDF generation diagram shows job queue polling, worker processing, R2 upload, Timing and activation bars clearly show which components are active, Error scenarios documented (e.g., OAuth provider down, Stripe API failure)",
    "dependencies": ["I1.T1"],
    "parallelizable": true,
    "done": true
  },
  {
    "task_id": "I2.T2",
    "iteration_id": "I2",
    "iteration_goal": "Implement calendar creation, editing, and template system. Build calendar editor UI components. Integrate astronomical calculations (moon phases, Hebrew calendar). Create sequence diagrams for key workflows",
    "description": "Create CalendarService with business logic for calendar operations: createCalendar (from template or blank), updateCalendar (modify config, events), deleteCalendar (soft delete or hard delete), getCalendar (by ID with authorization check), listCalendars (by user, with pagination). Implement CalendarRepository with Panache custom queries: findByUserId, findByShareToken, findTemplates (isActive=true). Handle calendar versioning (optimistic locking with version field). Implement session-to-user conversion (migrate calendars from CalendarSession to User on login). Add authorization checks (user can only access own calendars unless admin). Write unit tests for all service methods.",
    "agent_type_hint": "BackendAgent",
    "inputs": "Calendar entity model from I1.T8, GraphQL schema calendar queries/mutations from I1.T6, Calendar service requirements from Plan Section 2",
    "target_files": ["src/main/java/com/villagecompute/calendar/service/CalendarService.java", "src/main/java/com/villagecompute/calendar/repository/CalendarRepository.java", "src/test/java/com/villagecompute/calendar/service/CalendarServiceTest.java"],
    "input_files": ["src/main/java/com/villagecompute/calendar/model/Calendar.java", "src/main/java/com/villagecompute/calendar/model/User.java", "api/graphql-schema.graphql"],
    "deliverables": "CalendarService class with all CRUD methods implemented, CalendarRepository with custom query methods, Authorization logic (user can only access own calendars), Optimistic locking (version field prevents concurrent update conflicts), Unit tests achieving >80% code coverage for service layer",
    "acceptance_criteria": "CalendarService.createCalendar() persists new calendar to database, CalendarService.updateCalendar() throws exception if version mismatch, CalendarService.listCalendars(userId) returns only user's calendars, CalendarRepository.findByShareToken() returns public calendar or null, Authorization check throws UnauthorizedException if user accesses other user's calendar, All unit tests pass with ./mvnw test",
    "dependencies": ["I1.T8", "I1.T9"],
    "parallelizable": false,
    "done": true
  },
  {
    "task_id": "I2.T3",
    "iteration_id": "I2",
    "iteration_goal": "Implement calendar creation, editing, and template system. Build calendar editor UI components. Integrate astronomical calculations (moon phases, Hebrew calendar). Create sequence diagrams for key workflows",
    "description": "Create EventService for managing calendar events: addEvent (to calendar), updateEvent (text, emoji, color), deleteEvent, listEvents (by calendar, optionally filtered by date range). Implement EventRepository with custom queries: findByCalendarId, findByDateRange. Add validation: event date must be within calendar year, event text max 500 characters, emoji must be valid Unicode. Handle bulk event operations (import multiple events from CSV or JSON). Write unit tests for event service and repository.",
    "agent_type_hint": "BackendAgent",
    "inputs": "Event entity model from I1.T8, GraphQL schema event operations from I1.T6",
    "target_files": ["src/main/java/com/villagecompute/calendar/service/EventService.java", "src/main/java/com/villagecompute/calendar/repository/EventRepository.java", "src/test/java/com/villagecompute/calendar/service/EventServiceTest.java"],
    "input_files": ["src/main/java/com/villagecompute/calendar/model/Event.java", "src/main/java/com/villagecompute/calendar/model/Calendar.java", "api/graphql-schema.graphql"],
    "deliverables": "EventService class with CRUD and validation methods, EventRepository with custom queries, Validation logic for event fields, Unit tests with >80% coverage",
    "acceptance_criteria": "EventService.addEvent() validates event date is within calendar year, EventService.addEvent() rejects events with text >500 characters, EventRepository.findByDateRange() returns events within specified date range, Emoji validation accepts valid Unicode emoji sequences, Unit tests cover all validation scenarios and edge cases",
    "dependencies": ["I2.T2"],
    "parallelizable": true,
    "done": true
  },
  {
    "task_id": "I2.T4",
    "iteration_id": "I2",
    "iteration_goal": "Implement calendar creation, editing, and template system. Build calendar editor UI components. Integrate astronomical calculations (moon phases, Hebrew calendar). Create sequence diagrams for key workflows",
    "description": "Create TemplateService for managing calendar templates: createTemplate (admin only), updateTemplate, deleteTemplate (soft delete with isActive=false), listTemplates (public listing for users), applyTemplate (clone template config to new calendar). Implement TemplateRepository with queries: findActive, findById. Add RBAC enforcement (only admin role can create/edit templates). Implement template cloning logic (deep copy config JSONB, preserve event definitions). Create admin-specific GraphQL mutations (createTemplate, updateTemplate) with @RolesAllowed(\"admin\") annotation. Write integration tests for template application workflow.",
    "agent_type_hint": "BackendAgent",
    "inputs": "CalendarTemplate entity from I1.T8, Admin requirements from Plan Section \"Admin\" features, RBAC model from Plan Section 3.8.1",
    "target_files": ["src/main/java/com/villagecompute/calendar/service/TemplateService.java", "src/main/java/com/villagecompute/calendar/repository/TemplateRepository.java", "src/main/java/com/villagecompute/calendar/api/graphql/TemplateResolver.java", "src/test/java/com/villagecompute/calendar/service/TemplateServiceTest.java"],
    "input_files": ["src/main/java/com/villagecompute/calendar/model/CalendarTemplate.java", "src/main/java/com/villagecompute/calendar/model/Calendar.java", "api/graphql-schema.graphql"],
    "deliverables": "TemplateService with CRUD and cloning methods, TemplateRepository with active template queries, RBAC enforcement (admin-only template creation), GraphQL resolver for template mutations, Integration tests for template application",
    "acceptance_criteria": "TemplateService.createTemplate() throws UnauthorizedException if user role != admin, TemplateService.applyTemplate() creates new calendar with cloned config, TemplateRepository.findActive() returns only templates with isActive=true, Template cloning preserves all config fields (holidays, astronomy settings), GraphQL mutation createTemplate requires admin JWT token",
    "dependencies": ["I2.T2"],
    "parallelizable": true,
    "done": true
  },
  {
    "task_id": "I2.T5",
    "iteration_id": "I2",
    "iteration_goal": "Implement calendar creation, editing, and template system. Build calendar editor UI components. Integrate astronomical calculations (moon phases, Hebrew calendar). Create sequence diagrams for key workflows",
    "description": "Integrate SunCalc library (or Java port) for moon phase calculations and Proj4J for geospatial projections. Create AstronomicalService with methods: calculateMoonPhases (for calendar year, returns array of phase dates and illumination percentages), calculateHebrewCalendarDates (convert Gregorian dates to Hebrew calendar), calculateSeasonalEvents (equinoxes, solstices). Store calculation results in calendar.config JSONB field or separate table (if complex). Add configuration option in calendar editor to enable/disable astronomical overlays. Write unit tests verifying calculation accuracy against known astronomical data (e.g., 2025 full moon dates).",
    "agent_type_hint": "BackendAgent",
    "inputs": "Astronomical calculation requirements from Plan Section \"Features\", SunCalc and Proj4J library documentation",
    "target_files": ["src/main/java/com/villagecompute/calendar/service/AstronomicalService.java", "src/main/java/com/villagecompute/calendar/util/astronomical/MoonPhaseCalculator.java", "src/main/java/com/villagecompute/calendar/util/astronomical/HebrewCalendarConverter.java", "src/test/java/com/villagecompute/calendar/service/AstronomicalServiceTest.java"],
    "input_files": ["pom.xml", "src/main/java/com/villagecompute/calendar/model/Calendar.java"],
    "deliverables": "AstronomicalService class with calculation methods, SunCalc/Proj4J integration (Maven dependencies added), Moon phase and Hebrew calendar calculation logic, Unit tests verifying calculation accuracy",
    "acceptance_criteria": "AstronomicalService.calculateMoonPhases(2025) returns correct full moon dates for 2025, AstronomicalService.calculateHebrewCalendarDates() converts Gregorian to Hebrew dates accurately, Unit tests compare calculations against NASA moon phase data or Hebrew calendar tables, Service methods handle edge cases (leap years, timezone conversions), Calculation performance: <100ms for full year of moon phases",
    "dependencies": ["I2.T2"],
    "parallelizable": true,
    "done": true
  },
  {
    "task_id": "I2.T6",
    "iteration_id": "I2",
    "iteration_goal": "Implement calendar creation, editing, and template system. Build calendar editor UI components. Integrate astronomical calculations (moon phases, Hebrew calendar). Create sequence diagrams for key workflows",
    "description": "Replace stub implementations in CalendarResolver with real service calls. Implement queries: calendar(id) (fetch calendar with events, authorize user), calendars(userId, year) (list user's calendars with pagination). Implement mutations: createCalendar(input) (validate input, call CalendarService), updateCalendar(id, input) (authorize, update), deleteCalendar(id) (authorize, soft/hard delete). Inject SecurityIdentity for user context. Implement DataLoader pattern to prevent N+1 queries when fetching related entities (e.g., calendar with user and events). Add error handling (map service exceptions to GraphQL errors). Write integration tests for all resolver methods.",
    "agent_type_hint": "BackendAgent",
    "inputs": "CalendarService from Task I2.T2, EventService from Task I2.T3, GraphQL schema from I1.T6",
    "target_files": ["src/main/java/com/villagecompute/calendar/api/graphql/CalendarResolver.java", "src/main/java/com/villagecompute/calendar/api/graphql/dataloader/CalendarDataLoader.java", "src/test/java/com/villagecompute/calendar/api/graphql/CalendarResolverTest.java"],
    "input_files": ["src/main/java/com/villagecompute/calendar/service/CalendarService.java", "src/main/java/com/villagecompute/calendar/service/EventService.java", "src/main/java/com/villagecompute/calendar/api/graphql/CalendarResolver.java", "api/graphql-schema.graphql"],
    "deliverables": "All calendar query/mutation resolvers implemented, DataLoader pattern implemented for efficient queries, Authorization checks (user can only query own calendars), Error handling (service exceptions mapped to GraphQL errors), Integration tests for all resolvers",
    "acceptance_criteria": "GraphQL query { calendar(id: \"123\") { title events { eventText } } } returns calendar with events, Unauthorized access to other user's calendar returns GraphQL error, createCalendar mutation persists calendar and returns new ID, DataLoader batches queries (e.g., fetching 10 calendars with users requires 2 DB queries, not 11), Integration tests verify end-to-end GraphQL request/response flow",
    "dependencies": ["I2.T2", "I2.T3", "I1.T10"],
    "parallelizable": false,
    "done": true
  },
  {
    "task_id": "I2.T7",
    "iteration_id": "I2",
    "iteration_goal": "Implement calendar creation, editing, and template system. Build calendar editor UI components. Integrate astronomical calculations (moon phases, Hebrew calendar). Create sequence diagrams for key workflows",
    "description": "Create Vue.js components for the calendar editor interface: CalendarEditor.vue (main editor container, loads calendar data, manages state), CalendarGrid.vue (visual calendar grid with month/date layout), EventEditor.vue (form for adding/editing events), EmojiPicker.vue (emoji selection dialog), HolidaySelector.vue (checkbox list of holiday sets), AstronomyToggle.vue (enable/disable moon phases, Hebrew calendar). Use PrimeVue components (DataTable, Dialog, InputText, Calendar, MultiSelect, Checkbox). Implement calendar state management in Pinia store (calendarStore.ts). Integrate with GraphQL API (use queries to load calendar, mutations to save changes). Add real-time preview updates (calendar grid updates as user adds events). Handle loading states and error messages.",
    "agent_type_hint": "FrontendAgent",
    "inputs": "Calendar editor requirements from Plan Section \"Features\", PrimeVue component documentation, GraphQL schema from I1.T6",
    "target_files": ["frontend/src/views/CalendarEditor.vue", "frontend/src/components/calendar/CalendarGrid.vue", "frontend/src/components/calendar/EventEditor.vue", "frontend/src/components/calendar/EmojiPicker.vue", "frontend/src/components/calendar/HolidaySelector.vue", "frontend/src/components/calendar/AstronomyToggle.vue", "frontend/src/stores/calendar.ts", "frontend/src/graphql/calendar-queries.ts"],
    "input_files": ["frontend/src/views/CalendarEditor.vue", "frontend/src/stores/calendar.ts", "api/graphql-schema.graphql"],
    "deliverables": "Functional calendar editor UI with all sub-components, Calendar grid displays year with 12 months, dates clickable to add events, Event editor dialog allows adding/editing event text, emoji, color, Emoji picker shows categorized emoji list (PrimeVue Dialog + emoji data), Holiday selector updates calendar config in Pinia store, Astronomy toggle enables/disables moon phase and Hebrew calendar overlays, GraphQL integration (load calendar, save changes)",
    "acceptance_criteria": "Calendar editor loads existing calendar via GraphQL query on mount, Clicking date in calendar grid opens event editor dialog, Adding event updates Pinia store and triggers GraphQL mutation, Emoji picker allows selecting emoji, updates event in editor, Holiday selector changes persist to backend (updateCalendar mutation), Real-time preview: changes visible immediately without page reload, Loading spinner shown while GraphQL queries in flight, Error messages displayed if GraphQL mutations fail",
    "dependencies": ["I2.T6", "I1.T11"],
    "parallelizable": true,
    "done": true
  },
  {
    "task_id": "I2.T8",
    "iteration_id": "I2",
    "iteration_goal": "Implement calendar creation, editing, and template system. Build calendar editor UI components. Integrate astronomical calculations (moon phases, Hebrew calendar). Create sequence diagrams for key workflows",
    "description": "Create template gallery view component displaying admin-curated calendar templates. Implement TemplateGallery.vue with grid layout (PrimeVue DataView or custom grid), showing template thumbnails, names, descriptions. Add filtering (by category, year, holiday set - future expansion). Implement \"Start from Template\" button that creates new calendar based on selected template (calls createCalendar mutation with templateId). Create TemplateCard.vue component for individual template preview. Add loading states, empty state (\"No templates available\"), error handling. Integrate with GraphQL (query templates, mutation createCalendar).",
    "agent_type_hint": "FrontendAgent",
    "inputs": "Template gallery requirements from Plan Section \"Features\", PrimeVue DataView component documentation",
    "target_files": ["frontend/src/views/TemplateGallery.vue", "frontend/src/components/calendar/TemplateCard.vue", "frontend/src/graphql/template-queries.ts"],
    "input_files": ["frontend/src/views/Home.vue", "frontend/src/stores/calendar.ts", "api/graphql-schema.graphql"],
    "deliverables": "Template gallery view with grid layout, Template cards show thumbnail, name, description, \"Start from Template\" button creates new calendar, GraphQL integration (fetch templates, create calendar), Loading and error states handled",
    "acceptance_criteria": "Gallery loads templates via GraphQL query on mount, Template cards display thumbnail images (placeholder if none), Clicking \"Start from Template\" creates calendar and redirects to editor, Empty state shown if no active templates, Error message displayed if GraphQL query fails, Responsive design (grid adapts to mobile, tablet, desktop)",
    "dependencies": ["I2.T4", "I2.T6"],
    "parallelizable": true,
    "done": true
  },
  {
    "task_id": "I2.T9",
    "iteration_id": "I2",
    "iteration_goal": "Implement calendar creation, editing, and template system. Build calendar editor UI components. Integrate astronomical calculations (moon phases, Hebrew calendar). Create sequence diagrams for key workflows",
    "description": "Implement guest session management allowing anonymous users to create calendars before authenticating. Create SessionService for managing CalendarSession entities: createSession (generate UUID, store in localStorage), saveCalendarToSession (persist calendar data in JSONB session_data field), convertSessionToUser (on login, transfer session calendars to user account). Update CalendarService.createCalendar to accept optional sessionId (if user not authenticated). Update frontend to store sessionId in localStorage, include in GraphQL mutations if user not logged in. Implement session expiration (30 days, cleanup job deletes expired sessions). Add \"Sign in to save\" prompt in calendar editor for guest users.",
    "agent_type_hint": "BackendAgent",
    "inputs": "Guest session requirements from Plan Section \"User Experience\", CalendarSession entity from I1.T8",
    "target_files": ["src/main/java/com/villagecompute/calendar/service/SessionService.java", "src/main/java/com/villagecompute/calendar/repository/SessionRepository.java", "src/main/java/com/villagecompute/calendar/api/graphql/SessionResolver.java", "frontend/src/utils/session.ts", "src/test/java/com/villagecompute/calendar/service/SessionServiceTest.java"],
    "input_files": ["src/main/java/com/villagecompute/calendar/model/CalendarSession.java", "src/main/java/com/villagecompute/calendar/service/CalendarService.java", "frontend/src/stores/user.ts"],
    "deliverables": "SessionService with CRUD and conversion methods, CalendarService supports sessionId parameter for guest users, Frontend stores sessionId in localStorage, Session-to-user conversion on login (GraphQL mutation), Session expiration cleanup job (Quarkus Scheduler), Unit tests for session service",
    "acceptance_criteria": "Guest user can create calendar without logging in, Calendar saved to session (CalendarSession entity in database), sessionId persisted in browser localStorage, On login, convertGuestSession mutation transfers calendars to user account, Expired sessions (>30 days old) deleted by cleanup job, Frontend prompts guest user to sign in to save permanently",
    "dependencies": ["I2.T2", "I1.T9"],
    "parallelizable": true,
    "done": false
  },
  {
    "task_id": "I2.T10",
    "iteration_id": "I2",
    "iteration_goal": "Implement calendar creation, editing, and template system. Build calendar editor UI components. Integrate astronomical calculations (moon phases, Hebrew calendar). Create sequence diagrams for key workflows",
    "description": "Create end-to-end integration tests for critical calendar workflows using Quarkus test framework with REST Assured for GraphQL API testing. Test scenarios: (1) Create calendar from template - authenticate, query templates, create calendar from template, verify calendar created with correct config; (2) Add events to calendar - create calendar, add multiple events, query calendar with events, verify events returned; (3) Update calendar - create calendar, update config (enable astronomy), verify changes persisted; (4) Guest session conversion - create calendar as guest, authenticate, convert session, verify calendar transferred to user. Use test database (H2 or Testcontainers PostgreSQL). Achieve >70% code coverage for service and API layers.",
    "agent_type_hint": "BackendAgent",
    "inputs": "All implemented services and resolvers from I2 tasks, Quarkus testing and REST Assured documentation",
    "target_files": ["src/test/java/com/villagecompute/calendar/integration/CalendarWorkflowTest.java", "src/test/java/com/villagecompute/calendar/integration/TemplateWorkflowTest.java", "src/test/java/com/villagecompute/calendar/integration/GuestSessionWorkflowTest.java"],
    "input_files": ["api/graphql-schema.graphql"],
    "deliverables": "Integration tests for all critical calendar workflows, Tests use GraphQL API (not direct service calls), Test database setup and teardown automated, Tests achieve >70% coverage for service/API layers, All tests pass with ./mvnw verify",
    "acceptance_criteria": "Template workflow test creates calendar from template, verifies config cloned, Event workflow test adds 5 events, queries calendar, verifies all 5 returned, Update workflow test modifies calendar config, verifies changes in database, Guest session workflow test creates calendar as guest, converts on login, verifies ownership, Tests run in isolation (each test creates own test data, cleans up after), Integration tests complete in <60 seconds",
    "dependencies": ["I2.T2", "I2.T3", "I2.T4", "I2.T5", "I2.T6", "I2.T7", "I2.T8", "I2.T9"],
    "parallelizable": false,
    "done": false
  }
]
