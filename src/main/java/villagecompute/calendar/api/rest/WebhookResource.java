package villagecompute.calendar.api.rest;

import java.time.Instant;
import java.util.Optional;

import jakarta.annotation.security.PermitAll;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.media.Content;
import org.eclipse.microprofile.openapi.annotations.media.ExampleObject;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.eclipse.microprofile.openapi.annotations.parameters.Parameter;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponse;
import org.eclipse.microprofile.openapi.annotations.tags.Tag;
import org.jboss.logging.Logger;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.stripe.exception.SignatureVerificationException;
import com.stripe.model.Event;
import com.stripe.model.StripeObject;
import com.stripe.net.Webhook;

import villagecompute.calendar.data.models.CalendarOrder;
import villagecompute.calendar.services.OrderService;
import villagecompute.calendar.services.PaymentService;
import villagecompute.calendar.types.ErrorType;
import villagecompute.calendar.types.SuccessType;

/**
 * REST resource for handling Stripe webhooks. Validates webhook signatures and processes payment events.
 */
@Path("/webhooks")
@ApplicationScoped
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Tag(
        name = "Webhooks",
        description = "External webhook endpoints for payment processing")
public class WebhookResource {

    private static final Logger LOG = Logger.getLogger(WebhookResource.class);
    private static final ObjectMapper MAPPER = new ObjectMapper();

    public static final String STRIPE_OBJECT_PROPERTY = "object";
    private static final String STRIPE_PAYMENT_INTENT_PROPERTY = "payment_intent";
    private static final String STRIPE_METADATA_PROPERTY = "metadata";

    @Inject
    PaymentService paymentService;

    @Inject
    OrderService orderService;

    /**
     * Handle Stripe webhook events. Validates signature and processes payment intent events.
     *
     * @param payload
     *            Raw webhook payload
     * @param signatureHeader
     *            Stripe-Signature header value
     * @return Response indicating success or failure
     */
    @POST
    @Path("/stripe")
    @PermitAll
    @Transactional
    @Operation(
            summary = "Handle Stripe webhook events",
            description = "Processes Stripe payment webhook events with signature verification. This"
                    + " endpoint is called by Stripe when payment events occur. Supported event"
                    + " types: checkout.session.completed, payment_intent.succeeded,"
                    + " payment_intent.payment_failed, charge.refunded.")
    @APIResponse(
            responseCode = "200",
            description = "Webhook processed successfully",
            content = @Content(
                    mediaType = MediaType.APPLICATION_JSON,
                    schema = @Schema(
                            implementation = WebhookSuccessResponse.class),
                    examples = @ExampleObject(
                            value = "{\"status\": \"success\"}")))
    @APIResponse(
            responseCode = "400",
            description = "Invalid signature or malformed payload",
            content = @Content(
                    mediaType = MediaType.APPLICATION_JSON,
                    schema = @Schema(
                            implementation = WebhookErrorResponse.class),
                    examples = @ExampleObject(
                            value = "{\"error\": \"Invalid signature\"}")))
    @APIResponse(
            responseCode = "500",
            description = "Internal server error processing webhook",
            content = @Content(
                    mediaType = MediaType.APPLICATION_JSON,
                    schema = @Schema(
                            implementation = WebhookErrorResponse.class),
                    examples = @ExampleObject(
                            value = "{\"error\": \"Failed to process event\"}")))
    public Response handleStripeWebhook(@Parameter(
            description = "Raw JSON payload from Stripe webhook event",
            required = true,
            example = "{\"id\": \"evt_...\", \"type\": \"payment_intent.succeeded\","
                    + " \"data\": {...}}") String payload,
            @HeaderParam("Stripe-Signature") @Parameter(
                    description = "HMAC-SHA256 signature generated by Stripe using the webhook"
                            + " secret. Required for webhook signature verification to" + " prevent replay attacks.",
                    required = true,
                    example = "t=1234567890,v1=abc123...") String signatureHeader) {
        LOG.infof("Received Stripe webhook");

        // Validate signature
        if (signatureHeader == null || signatureHeader.isBlank()) {
            LOG.error("Missing Stripe-Signature header");
            return Response.status(Response.Status.BAD_REQUEST).entity(ErrorType.of("Missing signature header"))
                    .build();
        }

        Event event;
        try {
            String webhookSecret = paymentService.getWebhookSecret() != null ? paymentService.getWebhookSecret() : "";

            // Debug logging for webhook secret configuration
            if (webhookSecret == null || webhookSecret.isEmpty()) {
                LOG.error("WEBHOOK SECRET IS NOT CONFIGURED - webhook secret is null or empty");
            } else if (webhookSecret.equals("whsec_placeholder")) {
                LOG.error("WEBHOOK SECRET IS PLACEHOLDER - environment variable STRIPE_WEBHOOK_SECRET" + " not set");
            } else {
                LOG.infof("Webhook secret configured (length: %d, prefix: %s...)", webhookSecret.length(),
                        webhookSecret.substring(0, Math.min(10, webhookSecret.length())));
            }

            // Log signature header info
            LOG.infof("Stripe-Signature header length: %d, prefix: %s...", signatureHeader.length(),
                    signatureHeader.substring(0, Math.min(30, signatureHeader.length())));

            event = Webhook.constructEvent(payload, signatureHeader, webhookSecret);
            LOG.infof("Webhook signature validated successfully. Event type: %s", event.getType());
        } catch (SignatureVerificationException e) {
            LOG.errorf("Invalid webhook signature: %s", e.getMessage());
            LOG.errorf("SignatureVerificationException details - sigHeader length: %d, payload length:" + " %d",
                    signatureHeader.length(), payload != null ? payload.length() : 0);
            return Response.status(Response.Status.BAD_REQUEST).entity(ErrorType.of("Invalid signature")).build();
        } catch (Exception e) {
            LOG.errorf(e, "Failed to construct webhook event");
            return Response.status(Response.Status.BAD_REQUEST).entity(ErrorType.of("Invalid webhook payload")).build();
        }

        // Process the event
        try {
            processWebhookEvent(event);
            return Response.ok(SuccessType.ok()).build();
        } catch (Exception e) {
            LOG.errorf(e, "Failed to process webhook event");
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity(ErrorType.of("Failed to process event")).build();
        }
    }

    /**
     * Process different webhook event types.
     *
     * @param event
     *            Stripe event
     */
    private void processWebhookEvent(Event event) {
        String eventType = event.getType();
        LOG.infof("Processing webhook event: %s (ID: %s)", eventType, event.getId());

        switch (eventType) {
            case "checkout.session.completed" :
                handleCheckoutSessionCompleted(event);
                break;
            case "payment_intent.succeeded" :
                handlePaymentIntentSucceeded(event);
                break;
            case "payment_intent.payment_failed" :
                handlePaymentIntentFailed(event);
                break;
            case "charge.refunded" :
                handleChargeRefunded(event);
                break;
            default :
                LOG.debugf("Unhandled webhook event type: %s", eventType);
        }
    }

    /**
     * Handle Stripe Checkout Session completed event. This is the primary payment success event for embedded checkout
     * flow. Delegates to PaymentService which handles order updates and shipping info extraction.
     *
     * @param event
     *            Stripe event
     */
    private void handleCheckoutSessionCompleted(Event event) {
        // Deserialize the Session object from the event data
        com.stripe.model.checkout.Session session;
        try {
            // Try to deserialize directly from the event
            var deserializer = event.getDataObjectDeserializer();
            Optional<StripeObject> stripeObj = deserializer.getObject();
            if (stripeObj.isPresent()) {
                session = (com.stripe.model.checkout.Session) stripeObj.get();
            } else {
                // Fallback: parse from JSON manually for test compatibility
                String dataJson = event.getData().toJson();
                JsonNode sessionData = MAPPER.readTree(dataJson).get(STRIPE_OBJECT_PROPERTY);
                String sessionId = sessionData.get("id").asText();

                LOG.infof("Deserializing session from JSON, ID: %s", sessionId);

                // Create a minimal session object from JSON
                session = new com.stripe.model.checkout.Session();
                session.setId(sessionId);

                // Set payment intent if present
                if (sessionData.has(STRIPE_PAYMENT_INTENT_PROPERTY)
                        && !sessionData.get(STRIPE_PAYMENT_INTENT_PROPERTY).isNull()) {
                    session.setPaymentIntent(sessionData.get(STRIPE_PAYMENT_INTENT_PROPERTY).asText());
                }

                // Set metadata if present
                if (sessionData.has(STRIPE_METADATA_PROPERTY) && !sessionData.get(STRIPE_METADATA_PROPERTY).isNull()) {
                    java.util.Map<String, String> metadata = new java.util.HashMap<>();
                    JsonNode metadataNode = sessionData.get(STRIPE_METADATA_PROPERTY);
                    metadataNode.fieldNames()
                            .forEachRemaining(name -> metadata.put(name, metadataNode.get(name).asText()));
                    session.setMetadata(metadata);
                }
            }
        } catch (Exception e) {
            LOG.errorf(e, "Failed to parse checkout session from event");
            throw new IllegalStateException("Failed to parse checkout session data", e);
        }

        LOG.infof("Checkout session completed: %s (PaymentIntent: %s)", session.getId(), session.getPaymentIntent());

        if (session.getId() == null || session.getId().isEmpty()) {
            LOG.errorf("Checkout session has no ID");
            return;
        }

        // Use the Session object directly (no Stripe API call needed)
        paymentService.processCheckoutSessionCompleted(session);
    }

    /**
     * Handle successful payment (direct PaymentIntent flow). This event is for direct PaymentIntent integration (not
     * Checkout Sessions). Delegates to PaymentService for processing.
     *
     * @param event
     *            Stripe event
     */
    private void handlePaymentIntentSucceeded(Event event) {
        // Parse payment intent data from JSON - works in both test and production
        JsonNode paymentIntentData;
        try {
            String dataJson = event.getData().toJson();
            paymentIntentData = MAPPER.readTree(dataJson).get(STRIPE_OBJECT_PROPERTY);
        } catch (Exception e) {
            throw new IllegalStateException("Failed to parse payment intent data", e);
        }

        String paymentIntentId = paymentIntentData.get("id").asText();
        JsonNode chargeNode = paymentIntentData.get("latest_charge");
        String chargeId = chargeNode != null ? chargeNode.asText() : null;

        LOG.infof("Payment succeeded for PaymentIntent: %s (Charge: %s)", paymentIntentId, chargeId);

        if (paymentIntentId == null || paymentIntentId.isEmpty()) {
            LOG.errorf("Payment intent has no ID");
            return;
        }

        // Delegate to PaymentService for idempotent processing
        paymentService.processPaymentSuccess(paymentIntentId, chargeId);
    }

    /**
     * Handle failed payment. Logs the failure and updates order notes.
     *
     * @param event
     *            Stripe event
     */
    private void handlePaymentIntentFailed(Event event) {
        // Parse payment intent data from JSON - works in both test and production
        JsonNode paymentIntentData;
        try {
            String dataJson = event.getData().toJson();
            paymentIntentData = MAPPER.readTree(dataJson).get(STRIPE_OBJECT_PROPERTY);
        } catch (Exception e) {
            throw new IllegalStateException("Failed to parse payment intent data", e);
        }

        String paymentIntentId = paymentIntentData.get("id").asText();
        LOG.warnf("Payment failed for PaymentIntent: %s", paymentIntentId);

        if (paymentIntentId == null || paymentIntentId.isEmpty()) {
            LOG.errorf("Payment intent has no ID");
            return;
        }

        // Find the order
        Optional<CalendarOrder> orderOpt = orderService.findByStripePaymentIntent(paymentIntentId);
        if (orderOpt.isEmpty()) {
            LOG.errorf("Order not found for PaymentIntent: %s", paymentIntentId);
            return;
        }

        CalendarOrder order = orderOpt.get();

        // Add failure note - extract error message from last_payment_error
        JsonNode errorNode = paymentIntentData.get("last_payment_error");
        String failureMessage = (errorNode != null && errorNode.has("message")) ? errorNode.get("message").asText()
                : "Unknown error";

        String timestamp = Instant.now().toString();
        String noteEntry = String.format("[%s] Payment failed: %s%n", timestamp, failureMessage);
        order.notes = order.notes == null ? noteEntry : order.notes + noteEntry;
        order.persist();

        LOG.infof("Logged payment failure for order %s", order.id);
    }

    /**
     * Handle charge refunded event. Updates order notes with refund information. Delegates to PaymentService for
     * idempotent processing.
     *
     * @param event
     *            Stripe event
     */
    private void handleChargeRefunded(Event event) {
        // Parse charge data from JSON - works in both test and production
        JsonNode chargeData;
        try {
            String dataJson = event.getData().toJson();
            chargeData = MAPPER.readTree(dataJson).get(STRIPE_OBJECT_PROPERTY);
        } catch (Exception e) {
            throw new IllegalStateException("Failed to parse charge data", e);
        }

        String chargeId = chargeData.get("id").asText();
        LOG.infof("Charge refunded: %s", chargeId);

        if (chargeId == null || chargeId.isEmpty()) {
            LOG.errorf("Charge has no ID");
            return;
        }

        // Get refund details from the charge
        JsonNode refundsNode = chargeData.get("refunds");
        if (refundsNode == null || !refundsNode.has("data") || refundsNode.get("data").isEmpty()) {
            LOG.warnf("Charge %s refunded but no refund data available", chargeId);
            return;
        }

        // Get the most recent refund (Stripe sends one webhook per refund)
        JsonNode refundNode = refundsNode.get("data").get(0);
        String refundId = refundNode.get("id").asText();
        Long amountRefunded = refundNode.get("amount").asLong();

        if (refundId == null || refundId.isEmpty()) {
            LOG.warnf("Charge %s refunded but missing refund ID or amount", chargeId);
            return;
        }

        LOG.infof("Processing refund %s for charge %s, amount: %d cents", refundId, chargeId, amountRefunded);

        // Delegate to PaymentService for idempotent processing
        paymentService.processRefundWebhook(chargeId, refundId, amountRefunded);
    }

    /** Schema for successful webhook response. */
    @Schema(
            description = "Successful webhook processing response")
    public static class WebhookSuccessResponse {
        @Schema(
                description = "Status message",
                examples = "success")
        public String status;
    }

    /** Schema for webhook error response. */
    @Schema(
            description = "Webhook error response")
    public static class WebhookErrorResponse {
        @Schema(
                description = "Error message describing what went wrong",
                examples = "Invalid signature")
        public String error;
    }
}
