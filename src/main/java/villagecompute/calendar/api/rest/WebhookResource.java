package villagecompute.calendar.api.rest;

import com.stripe.exception.SignatureVerificationException;
import com.stripe.model.Event;
import com.stripe.model.PaymentIntent;
import com.stripe.net.Webhook;
import jakarta.annotation.security.PermitAll;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.enums.SecuritySchemeType;
import org.eclipse.microprofile.openapi.annotations.media.Content;
import org.eclipse.microprofile.openapi.annotations.media.ExampleObject;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.eclipse.microprofile.openapi.annotations.parameters.Parameter;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponse;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponses;
import org.eclipse.microprofile.openapi.annotations.security.SecurityRequirement;
import org.eclipse.microprofile.openapi.annotations.security.SecurityScheme;
import org.eclipse.microprofile.openapi.annotations.tags.Tag;
import org.jboss.logging.Logger;
import villagecompute.calendar.data.models.CalendarOrder;
import villagecompute.calendar.data.models.DelayedJob;
import villagecompute.calendar.data.models.DelayedJobQueue;
import villagecompute.calendar.services.OrderService;
import villagecompute.calendar.services.PaymentService;

import java.time.Instant;
import java.util.Optional;

/**
 * REST resource for handling Stripe webhooks.
 * Validates webhook signatures and processes payment events.
 */
@Path("/api/webhooks")
@ApplicationScoped
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Tag(name = "Webhooks", description = "External webhook endpoints for payment processing")
public class WebhookResource {

    private static final Logger LOG = Logger.getLogger(WebhookResource.class);

    @Inject
    PaymentService paymentService;

    @Inject
    OrderService orderService;

    /**
     * Handle Stripe webhook events.
     * Validates signature and processes payment intent events.
     *
     * @param payload Raw webhook payload
     * @param signatureHeader Stripe-Signature header value
     * @return Response indicating success or failure
     */
    @POST
    @Path("/stripe")
    @PermitAll
    @Transactional
    @Operation(
        summary = "Handle Stripe webhook events",
        description = "Processes Stripe payment webhook events with signature verification. " +
            "This endpoint is called by Stripe when payment events occur. " +
            "Supported event types: payment_intent.succeeded, payment_intent.payment_failed."
    )
    @APIResponses({
        @APIResponse(
            responseCode = "200",
            description = "Webhook processed successfully",
            content = @Content(
                mediaType = MediaType.APPLICATION_JSON,
                schema = @Schema(implementation = WebhookSuccessResponse.class),
                examples = @ExampleObject(value = "{\"status\": \"success\"}")
            )
        ),
        @APIResponse(
            responseCode = "400",
            description = "Invalid signature or malformed payload",
            content = @Content(
                mediaType = MediaType.APPLICATION_JSON,
                schema = @Schema(implementation = WebhookErrorResponse.class),
                examples = @ExampleObject(value = "{\"error\": \"Invalid signature\"}")
            )
        ),
        @APIResponse(
            responseCode = "500",
            description = "Internal server error processing webhook",
            content = @Content(
                mediaType = MediaType.APPLICATION_JSON,
                schema = @Schema(implementation = WebhookErrorResponse.class),
                examples = @ExampleObject(value = "{\"error\": \"Failed to process event\"}")
            )
        )
    })
    public Response handleStripeWebhook(
        @Parameter(
            description = "Raw JSON payload from Stripe webhook event",
            required = true,
            example = "{\"id\": \"evt_...\", \"type\": \"payment_intent.succeeded\", \"data\": {...}}"
        )
        String payload,
        @HeaderParam("Stripe-Signature")
        @Parameter(
            description = "HMAC-SHA256 signature generated by Stripe using the webhook secret. " +
                "Required for webhook signature verification to prevent replay attacks.",
            required = true,
            example = "t=1234567890,v1=abc123..."
        )
        String signatureHeader
    ) {
        LOG.infof("Received Stripe webhook");

        // Validate signature
        if (signatureHeader == null || signatureHeader.isBlank()) {
            LOG.error("Missing Stripe-Signature header");
            return Response.status(Response.Status.BAD_REQUEST)
                .entity(Map.of("error", "Missing signature header"))
                .build();
        }

        Event event;
        try {
            String webhookSecret = paymentService.getWebhookSecret();
            event = Webhook.constructEvent(payload, signatureHeader, webhookSecret);
            LOG.infof("Webhook signature validated successfully. Event type: %s", event.getType());
        } catch (SignatureVerificationException e) {
            LOG.errorf("Invalid webhook signature: %s", e.getMessage());
            return Response.status(Response.Status.BAD_REQUEST)
                .entity(Map.of("error", "Invalid signature"))
                .build();
        } catch (Exception e) {
            LOG.errorf(e, "Failed to construct webhook event");
            return Response.status(Response.Status.BAD_REQUEST)
                .entity(Map.of("error", "Invalid webhook payload"))
                .build();
        }

        // Process the event
        try {
            processWebhookEvent(event);
            return Response.ok(Map.of("status", "success")).build();
        } catch (Exception e) {
            LOG.errorf(e, "Failed to process webhook event");
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                .entity(Map.of("error", "Failed to process event"))
                .build();
        }
    }

    /**
     * Process different webhook event types.
     *
     * @param event Stripe event
     */
    private void processWebhookEvent(Event event) {
        String eventType = event.getType();
        LOG.infof("Processing webhook event: %s (ID: %s)", eventType, event.getId());

        switch (eventType) {
            case "payment_intent.succeeded":
                handlePaymentIntentSucceeded(event);
                break;
            case "payment_intent.payment_failed":
                handlePaymentIntentFailed(event);
                break;
            default:
                LOG.debugf("Unhandled webhook event type: %s", eventType);
        }
    }

    /**
     * Handle successful payment.
     * Updates order status to PAID and enqueues confirmation email.
     *
     * @param event Stripe event
     */
    private void handlePaymentIntentSucceeded(Event event) {
        PaymentIntent paymentIntent = (PaymentIntent) event.getDataObjectDeserializer()
            .getObject()
            .orElseThrow(() -> new IllegalStateException("Missing payment intent data"));

        String paymentIntentId = paymentIntent.getId();
        LOG.infof("Payment succeeded for PaymentIntent: %s", paymentIntentId);

        // Find the order
        Optional<CalendarOrder> orderOpt = orderService.findByStripePaymentIntent(paymentIntentId);
        if (orderOpt.isEmpty()) {
            LOG.errorf("Order not found for PaymentIntent: %s", paymentIntentId);
            return;
        }

        CalendarOrder order = orderOpt.get();

        // Update order status to PAID
        if (!CalendarOrder.STATUS_PAID.equals(order.status)) {
            order.status = CalendarOrder.STATUS_PAID;
            order.paidAt = Instant.now();

            // Store charge ID if available
            if (paymentIntent.getLatestCharge() != null) {
                order.stripeChargeId = paymentIntent.getLatestCharge();
            }

            order.persist();
            LOG.infof("Order %s marked as PAID", order.id);

            // Enqueue confirmation email
            DelayedJob emailJob = DelayedJob.createDelayedJob(
                order.id.toString(),
                DelayedJobQueue.EMAIL_ORDER_CONFIRMATION,
                Instant.now() // Send immediately
            );
            LOG.infof("Enqueued order confirmation email job %s for order %s",
                emailJob.id, order.id);
        } else {
            LOG.infof("Order %s already marked as PAID, skipping update", order.id);
        }
    }

    /**
     * Handle failed payment.
     * Logs the failure and updates order notes.
     *
     * @param event Stripe event
     */
    private void handlePaymentIntentFailed(Event event) {
        PaymentIntent paymentIntent = (PaymentIntent) event.getDataObjectDeserializer()
            .getObject()
            .orElseThrow(() -> new IllegalStateException("Missing payment intent data"));

        String paymentIntentId = paymentIntent.getId();
        LOG.warnf("Payment failed for PaymentIntent: %s", paymentIntentId);

        // Find the order
        Optional<CalendarOrder> orderOpt = orderService.findByStripePaymentIntent(paymentIntentId);
        if (orderOpt.isEmpty()) {
            LOG.errorf("Order not found for PaymentIntent: %s", paymentIntentId);
            return;
        }

        CalendarOrder order = orderOpt.get();

        // Add failure note
        String failureMessage = paymentIntent.getLastPaymentError() != null
            ? paymentIntent.getLastPaymentError().getMessage()
            : "Unknown error";

        String timestamp = Instant.now().toString();
        String noteEntry = String.format("[%s] Payment failed: %s\n", timestamp, failureMessage);
        order.notes = order.notes == null ? noteEntry : order.notes + noteEntry;
        order.persist();

        LOG.infof("Logged payment failure for order %s", order.id);
    }

    /**
     * Helper class for error responses.
     */
    private static class Map {
        static java.util.Map<String, String> of(String key, String value) {
            return java.util.Collections.singletonMap(key, value);
        }
    }

    /**
     * Schema for successful webhook response.
     */
    @Schema(description = "Successful webhook processing response")
    public static class WebhookSuccessResponse {
        @Schema(description = "Status message", example = "success")
        public String status;
    }

    /**
     * Schema for webhook error response.
     */
    @Schema(description = "Webhook error response")
    public static class WebhookErrorResponse {
        @Schema(description = "Error message describing what went wrong", example = "Invalid signature")
        public String error;
    }
}
