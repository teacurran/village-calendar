package villagecompute.calendar.api.rest;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.stripe.exception.SignatureVerificationException;
import com.stripe.model.Charge;
import com.stripe.model.Event;
import com.stripe.model.PaymentIntent;
import com.stripe.model.Refund;
import com.stripe.model.checkout.Session;
import com.stripe.net.Webhook;
import jakarta.annotation.security.PermitAll;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.enums.SecuritySchemeType;
import org.eclipse.microprofile.openapi.annotations.media.Content;
import org.eclipse.microprofile.openapi.annotations.media.ExampleObject;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.eclipse.microprofile.openapi.annotations.parameters.Parameter;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponse;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponses;
import org.eclipse.microprofile.openapi.annotations.security.SecurityRequirement;
import org.eclipse.microprofile.openapi.annotations.security.SecurityScheme;
import org.eclipse.microprofile.openapi.annotations.tags.Tag;
import org.jboss.logging.Logger;
import villagecompute.calendar.data.models.CalendarOrder;
import villagecompute.calendar.data.models.DelayedJob;
import villagecompute.calendar.data.models.DelayedJobQueue;
import villagecompute.calendar.services.OrderService;
import villagecompute.calendar.services.PaymentService;

import java.time.Instant;
import java.util.Optional;

/**
 * REST resource for handling Stripe webhooks.
 * Validates webhook signatures and processes payment events.
 */
@Path("/api/webhooks")
@ApplicationScoped
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Tag(name = "Webhooks", description = "External webhook endpoints for payment processing")
public class WebhookResource {

    private static final Logger LOG = Logger.getLogger(WebhookResource.class);
    private static final ObjectMapper MAPPER = new ObjectMapper();

    @Inject
    PaymentService paymentService;

    @Inject
    OrderService orderService;

    /**
     * Handle Stripe webhook events.
     * Validates signature and processes payment intent events.
     *
     * @param payload Raw webhook payload
     * @param signatureHeader Stripe-Signature header value
     * @return Response indicating success or failure
     */
    @POST
    @Path("/stripe")
    @PermitAll
    @Transactional
    @Operation(
        summary = "Handle Stripe webhook events",
        description = "Processes Stripe payment webhook events with signature verification. " +
            "This endpoint is called by Stripe when payment events occur. " +
            "Supported event types: checkout.session.completed, payment_intent.succeeded, " +
            "payment_intent.payment_failed, charge.refunded."
    )
    @APIResponses({
        @APIResponse(
            responseCode = "200",
            description = "Webhook processed successfully",
            content = @Content(
                mediaType = MediaType.APPLICATION_JSON,
                schema = @Schema(implementation = WebhookSuccessResponse.class),
                examples = @ExampleObject(value = "{\"status\": \"success\"}")
            )
        ),
        @APIResponse(
            responseCode = "400",
            description = "Invalid signature or malformed payload",
            content = @Content(
                mediaType = MediaType.APPLICATION_JSON,
                schema = @Schema(implementation = WebhookErrorResponse.class),
                examples = @ExampleObject(value = "{\"error\": \"Invalid signature\"}")
            )
        ),
        @APIResponse(
            responseCode = "500",
            description = "Internal server error processing webhook",
            content = @Content(
                mediaType = MediaType.APPLICATION_JSON,
                schema = @Schema(implementation = WebhookErrorResponse.class),
                examples = @ExampleObject(value = "{\"error\": \"Failed to process event\"}")
            )
        )
    })
    public Response handleStripeWebhook(
        @Parameter(
            description = "Raw JSON payload from Stripe webhook event",
            required = true,
            example = "{\"id\": \"evt_...\", \"type\": \"payment_intent.succeeded\", \"data\": {...}}"
        )
        String payload,
        @HeaderParam("Stripe-Signature")
        @Parameter(
            description = "HMAC-SHA256 signature generated by Stripe using the webhook secret. " +
                "Required for webhook signature verification to prevent replay attacks.",
            required = true,
            example = "t=1234567890,v1=abc123..."
        )
        String signatureHeader
    ) {
        LOG.infof("Received Stripe webhook");

        // Validate signature
        if (signatureHeader == null || signatureHeader.isBlank()) {
            LOG.error("Missing Stripe-Signature header");
            return Response.status(Response.Status.BAD_REQUEST)
                .entity(Map.of("error", "Missing signature header"))
                .build();
        }

        Event event;
        try {
            String webhookSecret = paymentService.getWebhookSecret();
            event = Webhook.constructEvent(payload, signatureHeader, webhookSecret);
            LOG.infof("Webhook signature validated successfully. Event type: %s", event.getType());
        } catch (SignatureVerificationException e) {
            LOG.errorf("Invalid webhook signature: %s", e.getMessage());
            return Response.status(Response.Status.BAD_REQUEST)
                .entity(Map.of("error", "Invalid signature"))
                .build();
        } catch (Exception e) {
            LOG.errorf(e, "Failed to construct webhook event");
            return Response.status(Response.Status.BAD_REQUEST)
                .entity(Map.of("error", "Invalid webhook payload"))
                .build();
        }

        // Process the event
        try {
            processWebhookEvent(event);
            return Response.ok(Map.of("status", "success")).build();
        } catch (Exception e) {
            LOG.errorf(e, "Failed to process webhook event");
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                .entity(Map.of("error", "Failed to process event"))
                .build();
        }
    }

    /**
     * Process different webhook event types.
     *
     * @param event Stripe event
     */
    private void processWebhookEvent(Event event) {
        String eventType = event.getType();
        LOG.infof("Processing webhook event: %s (ID: %s)", eventType, event.getId());

        switch (eventType) {
            case "checkout.session.completed":
                handleCheckoutSessionCompleted(event);
                break;
            case "payment_intent.succeeded":
                handlePaymentIntentSucceeded(event);
                break;
            case "payment_intent.payment_failed":
                handlePaymentIntentFailed(event);
                break;
            case "charge.refunded":
                handleChargeRefunded(event);
                break;
            default:
                LOG.debugf("Unhandled webhook event type: %s", eventType);
        }
    }

    /**
     * Handle Stripe Checkout Session completed event.
     * This is the primary payment success event for hosted checkout flow.
     * Extracts payment intent from session and delegates to PaymentService.
     *
     * @param event Stripe event
     */
    private void handleCheckoutSessionCompleted(Event event) {
        // Parse session data from JSON - works in both test and production
        JsonNode sessionData;
        try {
            String dataJson = event.getData().toJson();
            sessionData = MAPPER.readTree(dataJson).get("object");
        } catch (Exception e) {
            throw new IllegalStateException("Failed to parse checkout session data", e);
        }

        String sessionId = sessionData.get("id").asText();
        JsonNode paymentIntentNode = sessionData.get("payment_intent");
        String paymentIntentId = paymentIntentNode != null ? paymentIntentNode.asText() : null;

        LOG.infof("Checkout session completed: %s (PaymentIntent: %s)", sessionId, paymentIntentId);

        if (paymentIntentId == null || paymentIntentId.equals("null") || paymentIntentId.isEmpty()) {
            LOG.errorf("Checkout session %s has no PaymentIntent", sessionId);
            return;
        }

        // Delegate to PaymentService for idempotent processing
        paymentService.processPaymentSuccess(paymentIntentId, null);
    }

    /**
     * Handle successful payment (direct PaymentIntent flow).
     * This event is for direct PaymentIntent integration (not Checkout Sessions).
     * Delegates to PaymentService for processing.
     *
     * @param event Stripe event
     */
    private void handlePaymentIntentSucceeded(Event event) {
        // Parse payment intent data from JSON - works in both test and production
        JsonNode paymentIntentData;
        try {
            String dataJson = event.getData().toJson();
            paymentIntentData = MAPPER.readTree(dataJson).get("object");
        } catch (Exception e) {
            throw new IllegalStateException("Failed to parse payment intent data", e);
        }

        String paymentIntentId = paymentIntentData.get("id").asText();
        JsonNode chargeNode = paymentIntentData.get("latest_charge");
        String chargeId = chargeNode != null ? chargeNode.asText() : null;

        LOG.infof("Payment succeeded for PaymentIntent: %s (Charge: %s)", paymentIntentId, chargeId);

        if (paymentIntentId == null || paymentIntentId.isEmpty()) {
            LOG.errorf("Payment intent has no ID");
            return;
        }

        // Delegate to PaymentService for idempotent processing
        paymentService.processPaymentSuccess(paymentIntentId, chargeId);
    }

    /**
     * Handle failed payment.
     * Logs the failure and updates order notes.
     *
     * @param event Stripe event
     */
    private void handlePaymentIntentFailed(Event event) {
        // Parse payment intent data from JSON - works in both test and production
        JsonNode paymentIntentData;
        try {
            String dataJson = event.getData().toJson();
            paymentIntentData = MAPPER.readTree(dataJson).get("object");
        } catch (Exception e) {
            throw new IllegalStateException("Failed to parse payment intent data", e);
        }

        String paymentIntentId = paymentIntentData.get("id").asText();
        LOG.warnf("Payment failed for PaymentIntent: %s", paymentIntentId);

        if (paymentIntentId == null || paymentIntentId.isEmpty()) {
            LOG.errorf("Payment intent has no ID");
            return;
        }

        // Find the order
        Optional<CalendarOrder> orderOpt = orderService.findByStripePaymentIntent(paymentIntentId);
        if (orderOpt.isEmpty()) {
            LOG.errorf("Order not found for PaymentIntent: %s", paymentIntentId);
            return;
        }

        CalendarOrder order = orderOpt.get();

        // Add failure note - extract error message from last_payment_error
        JsonNode errorNode = paymentIntentData.get("last_payment_error");
        String failureMessage = (errorNode != null && errorNode.has("message"))
            ? errorNode.get("message").asText()
            : "Unknown error";

        String timestamp = Instant.now().toString();
        String noteEntry = String.format("[%s] Payment failed: %s\n", timestamp, failureMessage);
        order.notes = order.notes == null ? noteEntry : order.notes + noteEntry;
        order.persist();

        LOG.infof("Logged payment failure for order %s", order.id);
    }

    /**
     * Handle charge refunded event.
     * Updates order notes with refund information.
     * Delegates to PaymentService for idempotent processing.
     *
     * @param event Stripe event
     */
    private void handleChargeRefunded(Event event) {
        // Parse charge data from JSON - works in both test and production
        JsonNode chargeData;
        try {
            String dataJson = event.getData().toJson();
            chargeData = MAPPER.readTree(dataJson).get("object");
        } catch (Exception e) {
            throw new IllegalStateException("Failed to parse charge data", e);
        }

        String chargeId = chargeData.get("id").asText();
        LOG.infof("Charge refunded: %s", chargeId);

        if (chargeId == null || chargeId.isEmpty()) {
            LOG.errorf("Charge has no ID");
            return;
        }

        // Get refund details from the charge
        JsonNode refundsNode = chargeData.get("refunds");
        if (refundsNode == null || !refundsNode.has("data") || refundsNode.get("data").isEmpty()) {
            LOG.warnf("Charge %s refunded but no refund data available", chargeId);
            return;
        }

        // Get the most recent refund (Stripe sends one webhook per refund)
        JsonNode refundNode = refundsNode.get("data").get(0);
        String refundId = refundNode.get("id").asText();
        Long amountRefunded = refundNode.get("amount").asLong();

        if (refundId == null || refundId.isEmpty() || amountRefunded == null) {
            LOG.warnf("Charge %s refunded but missing refund ID or amount", chargeId);
            return;
        }

        LOG.infof("Processing refund %s for charge %s, amount: %d cents", refundId, chargeId, amountRefunded);

        // Delegate to PaymentService for idempotent processing
        paymentService.processRefundWebhook(chargeId, refundId, amountRefunded);
    }

    /**
     * Helper class for error responses.
     */
    private static class Map {
        static java.util.Map<String, String> of(String key, String value) {
            return java.util.Collections.singletonMap(key, value);
        }
    }

    /**
     * Schema for successful webhook response.
     */
    @Schema(description = "Successful webhook processing response")
    public static class WebhookSuccessResponse {
        @Schema(description = "Status message", example = "success")
        public String status;
    }

    /**
     * Schema for webhook error response.
     */
    @Schema(description = "Webhook error response")
    public static class WebhookErrorResponse {
        @Schema(description = "Error message describing what went wrong", example = "Invalid signature")
        public String error;
    }
}
