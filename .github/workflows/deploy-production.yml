name: Deploy to Production Environment

on:
  workflow_dispatch:

env:
  REGISTRY: docker.io
  IMAGE_NAME: village-calendar
  USE_WIREGUARD: ${{ secrets.USE_WIREGUARD || 'false' }}
  DEPLOYMENT_NAMESPACE: calendar-prod

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set image tag
        id: image_tag
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"
          echo "tag=${BRANCH_NAME}-${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "sha_tag=${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ steps.image_tag.outputs.tag }}
            type=raw,value=${{ steps.image_tag.outputs.sha_tag }}
            type=raw,value=latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

    outputs:
      image_tag: ${{ steps.image_tag.outputs.tag }}

  deploy:
    name: Deploy to Production (k3s)
    runs-on: ubuntu-latest
    needs: build
    # IMPORTANT: This 'environment' setting creates a manual approval gate
    # Configure this in GitHub: Settings > Environments > production > Required reviewers
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup WireGuard
        if: env.USE_WIREGUARD == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y wireguard-tools

          # Validate and clean secrets (remove any whitespace/newlines)
          WG_ADDRESS=$(echo -n "${{ secrets.WIREGUARD_ADDRESS }}" | tr -d '[:space:]')
          WG_PRIVATE_KEY=$(echo -n "${{ secrets.WIREGUARD_PRIVATE_KEY }}" | tr -d '[:space:]')
          WG_PEER_PUBLIC_KEY=$(echo -n "${{ secrets.WIREGUARD_PEER_PUBLIC_KEY }}" | tr -d '[:space:]')
          WG_ENDPOINT=$(echo -n "${{ secrets.WIREGUARD_ENDPOINT }}" | tr -d '[:space:]')
          WG_ALLOWED_IPS=$(echo -n "${{ secrets.WIREGUARD_ALLOWED_IPS }}" | tr -d '[:space:]')

          echo "=== Validating secrets ==="
          echo "Address: ${WG_ADDRESS}"
          echo "Address length: ${#WG_ADDRESS}"
          echo "Private key length: ${#WG_PRIVATE_KEY}"
          echo "Peer public key length: ${#WG_PEER_PUBLIC_KEY}"
          echo "Endpoint: ${WG_ENDPOINT}"
          echo "Endpoint length: ${#WG_ENDPOINT}"
          echo "AllowedIPs: ${WG_ALLOWED_IPS}"
          echo "AllowedIPs length: ${#WG_ALLOWED_IPS}"

          # Validate endpoint format (should be host:port)
          if [[ ! "$WG_ENDPOINT" =~ ^[^:]+:[0-9]+$ ]]; then
            echo "ERROR: WIREGUARD_ENDPOINT format is invalid!"
            echo "Expected format: hostname:port or ip:port"
            echo "Example: vpn.example.com:51820 or 203.0.113.1:51820"
            exit 1
          fi

          # Extract hostname and test DNS resolution
          WG_HOST=$(echo "$WG_ENDPOINT" | cut -d: -f1)
          WG_PORT=$(echo "$WG_ENDPOINT" | cut -d: -f2)
          echo ""
          echo "=== Testing endpoint resolution ==="
          echo "Host part: ${WG_HOST:0:10}... (first 10 chars)"
          echo "Port: $WG_PORT"

          # Test if hostname resolves
          if ! getent hosts "$WG_HOST" > /dev/null 2>&1; then
            echo "WARNING: Cannot resolve hostname '$WG_HOST'"
            echo "Trying direct IP check..."
            if [[ ! "$WG_HOST" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ERROR: Not a valid IP address either!"
              echo "Please check your WIREGUARD_ENDPOINT secret."
              echo "It should be either:"
              echo "  - A resolvable hostname with port (e.g., vpn.example.com:51820)"
              echo "  - An IP address with port (e.g., 203.0.113.1:51820)"
              exit 1
            else
              echo "Valid IP format detected, continuing..."
            fi
          else
            echo "Hostname resolves successfully"
          fi

          # Create WireGuard config
          sudo mkdir -p /etc/wireguard

          # Write config with cleaned values
          sudo tee /etc/wireguard/wg0.conf > /dev/null <<EOF
          [Interface]
          Address = ${WG_ADDRESS}
          PrivateKey = ${WG_PRIVATE_KEY}

          [Peer]
          PublicKey = ${WG_PEER_PUBLIC_KEY}
          Endpoint = ${WG_ENDPOINT}
          AllowedIPs = ${WG_ALLOWED_IPS}
          PersistentKeepalive = 25
          EOF

          sudo chmod 600 /etc/wireguard/wg0.conf

          # Debug: Show config structure (secrets will be masked by GitHub)
          echo "=== WireGuard config structure ==="
          sudo cat /etc/wireguard/wg0.conf

          echo ""
          echo "=== Config file line count ==="
          sudo wc -l /etc/wireguard/wg0.conf

          echo ""
          echo "=== Checking for invalid characters ==="
          sudo cat -A /etc/wireguard/wg0.conf | head -20

          # Connect
          echo ""
          echo "=== Attempting to bring up WireGuard ==="
          sudo wg-quick up wg0

          # Test connection
          ping -c 3 10.50.0.20

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.K3S_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Configure SSH with keep-alive settings to prevent connection drops
          cat >> ~/.ssh/config <<EOF
          Host *
            ServerAliveInterval 30
            ServerAliveCountMax 10
            TCPKeepAlive yes
            ConnectionAttempts 3
          EOF

          # Add host key (use private IP if WireGuard, public if direct)
          if [ "${{ env.USE_WIREGUARD }}" == "true" ]; then
            # For WireGuard, accept any host key for the private IP (since it's over VPN)
            echo "Host 10.50.0.20" >> ~/.ssh/config
            echo "  StrictHostKeyChecking no" >> ~/.ssh/config
            echo "  UserKnownHostsFile /dev/null" >> ~/.ssh/config
          else
            # For direct SSH, use the provided host key
            echo "${{ secrets.K3S_HOST }} ssh-rsa ${{ secrets.K3S_HOST_KEY }}" >> ~/.ssh/known_hosts
          fi

      - name: Deploy with Ansible (Production Environment)
        env:
          REGISTRY_USER: ${{ secrets.DOCKER_USERNAME }}
          REGISTRY_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
          K3S_HOST: ${{ env.USE_WIREGUARD == 'true' && '10.50.0.20' || secrets.K3S_HOST }}
          K3S_USER: ${{ secrets.K3S_USER }}
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          OBJECT_STORAGE_REGION: ${{ secrets.OBJECT_STORAGE_REGION }}
          OBJECT_STORAGE_BUCKET_NAME: ${{ secrets.OBJECT_STORAGE_BUCKET_NAME }}
          OBJECT_STORAGE_ENDPOINT_URL: ${{ secrets.OBJECT_STORAGE_ENDPOINT_URL }}
          OBJECT_STORAGE_CDN_URL: ${{ secrets.OBJECT_STORAGE_CDN_URL }}
          OBJECT_STORAGE_ACCESS_KEY: ${{ secrets.OBJECT_STORAGE_ACCESS_KEY }}
          OBJECT_STORAGE_SECRET_KEY: ${{ secrets.OBJECT_STORAGE_SECRET_KEY }}
          SESSION_ENCRYPTION_KEY: ${{ secrets.SESSION_ENCRYPTION_KEY }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID_PROD }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET_PROD }}
          INGRESS_HOST: calendar.villagecompute.com
          DEPLOYMENT_NAMESPACE: ${{ env.DEPLOYMENT_NAMESPACE }}
        run: |
          # Install Ansible
          python -m pip install --upgrade pip
          pip install ansible docker

          # Create inventory
          cat > inventory.yml <<EOF
          all:
            hosts:
              k3s_cluster:
                ansible_host: ${K3S_HOST}
                ansible_user: ${K3S_USER}
                ansible_ssh_private_key_file: ~/.ssh/id_rsa
                ansible_python_interpreter: /usr/bin/python3
          EOF

          # Run deployment (override namespace for production)
          ansible-playbook \
            -i inventory.yml \
            -e "k8s_namespace=${DEPLOYMENT_NAMESPACE}" \
            -e "quarkus_profile=production" \
            ansible/deploy-calendar.yml

      - name: Wait for rollout completion
        env:
          K3S_HOST: ${{ env.USE_WIREGUARD == 'true' && '10.50.0.20' || secrets.K3S_HOST }}
          K3S_USER: ${{ secrets.K3S_USER }}
        run: |
          ssh -o StrictHostKeyChecking=no ${K3S_USER}@${K3S_HOST} \
            "kubectl rollout status deployment/calendar -n ${DEPLOYMENT_NAMESPACE} --timeout=5m"

      - name: Run smoke tests
        env:
          K3S_HOST: ${{ env.USE_WIREGUARD == 'true' && '10.50.0.20' || secrets.K3S_HOST }}
          K3S_USER: ${{ secrets.K3S_USER }}
        run: |
          echo "Running health check..."
          HEALTH_OUTPUT=$(ssh -o StrictHostKeyChecking=no ${K3S_USER}@${K3S_HOST} \
            "kubectl run smoke-test-health --rm -i --restart=Never --image=curlimages/curl:latest -n ${DEPLOYMENT_NAMESPACE} -- \
            curl -s -o /dev/null -w '%{http_code}' http://calendar-service.${DEPLOYMENT_NAMESPACE}.svc.cluster.local/q/health/live" 2>&1)

          # Extract just the HTTP status code (first 3 digits)
          HEALTH_STATUS=$(echo "${HEALTH_OUTPUT}" | grep -oE '^[0-9]{3}' | head -1)

          echo "Health check output: ${HEALTH_OUTPUT}"
          echo "Health check status: ${HEALTH_STATUS}"
          if [ "${HEALTH_STATUS}" != "200" ]; then
            echo "Health check failed with status ${HEALTH_STATUS}"
            exit 1
          fi

          echo "Running GraphQL smoke test..."
          GRAPHQL_OUTPUT=$(ssh -o StrictHostKeyChecking=no ${K3S_USER}@${K3S_HOST} \
            "kubectl run smoke-test-graphql --rm -i --restart=Never --image=curlimages/curl:latest -n ${DEPLOYMENT_NAMESPACE} -- \
            curl -s -X POST http://calendar-service.${DEPLOYMENT_NAMESPACE}.svc.cluster.local/graphql \
            -H 'Content-Type: application/json' \
            -d '{\"query\":\"query { __typename }\"}'") 2>&1

          # Filter out kubectl messages, keep only JSON response
          GRAPHQL_RESPONSE=$(echo "${GRAPHQL_OUTPUT}" | grep -v "^pod " | head -1)

          echo "GraphQL response: ${GRAPHQL_RESPONSE}"
          if echo "${GRAPHQL_RESPONSE}" | grep -q '"errors"'; then
            echo "GraphQL query failed"
            exit 1
          fi

          echo "All smoke tests passed!"

      - name: Upload generated manifest for debugging
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: k8s-manifest-production
          path: /tmp/calendar-k8s.yaml
          retention-days: 7

      - name: Disconnect WireGuard
        if: always() && env.USE_WIREGUARD == 'true'
        run: |
          sudo wg-quick down wg0 || true

      - name: Notify deployment success
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const sha = '${{ github.sha }}';
            const shortSha = sha.substring(0, 7);

            if (context.payload.pull_request) {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âœ… Deployed to production (${shortSha})\n\nView at: https://calendar.villagecompute.com`
              });
            }

      - name: Rollback instructions
        if: failure()
        run: |
          echo "::warning::Deployment failed! To rollback, run:"
          echo "kubectl rollout undo deployment/calendar -n ${DEPLOYMENT_NAMESPACE}"
          echo ""
          echo "Or manually deploy a previous version:"
          echo "kubectl set image deployment/calendar calendar=\$DOCKER_USERNAME/village-calendar:<previous-tag> -n ${DEPLOYMENT_NAMESPACE}"
