name: Deploy to Beta Environment

on:
  # Only deploy after CI workflow completes successfully on beta branch
  workflow_run:
    workflows: ["Continuous Integration"]
    types: [completed]
    branches:
      - beta
  # Allow manual deploys
  workflow_dispatch:

env:
  REGISTRY: docker.io
  IMAGE_NAME: village-calendar
  USE_WIREGUARD: ${{ secrets.USE_WIREGUARD || 'false' }}
  DEPLOYMENT_NAMESPACE: calendar-beta

jobs:
  # Only build if manually triggered (CI already built the image for workflow_run)
  build:
    name: Build Docker Image (manual only)
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:sha-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Beta (k3s)
    runs-on: ubuntu-latest
    # Wait for build if it's running (manual trigger), otherwise proceed (workflow_run)
    needs: [build]
    # Run if: (workflow_run AND CI passed AND build skipped) OR (workflow_dispatch AND build succeeded)
    if: |
      always() &&
      (
        (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' && needs.build.result == 'skipped') ||
        (github.event_name == 'workflow_dispatch' && needs.build.result == 'success')
      )
    environment: beta

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # For workflow_run, checkout the commit that triggered CI; for workflow_dispatch, use default
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Setup WireGuard
        if: env.USE_WIREGUARD == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y wireguard-tools

          # Validate and clean secrets (remove any whitespace/newlines)
          WG_ADDRESS=$(echo -n "${{ secrets.WIREGUARD_ADDRESS }}" | tr -d '[:space:]')
          WG_PRIVATE_KEY=$(echo -n "${{ secrets.WIREGUARD_PRIVATE_KEY }}" | tr -d '[:space:]')
          WG_PEER_PUBLIC_KEY=$(echo -n "${{ secrets.WIREGUARD_PEER_PUBLIC_KEY }}" | tr -d '[:space:]')
          WG_ENDPOINT=$(echo -n "${{ secrets.WIREGUARD_ENDPOINT }}" | tr -d '[:space:]')
          WG_ALLOWED_IPS=$(echo -n "${{ secrets.WIREGUARD_ALLOWED_IPS }}" | tr -d '[:space:]')

          echo "=== Validating secrets ==="
          echo "Address: ${WG_ADDRESS}"
          echo "Address length: ${#WG_ADDRESS}"
          echo "Private key length: ${#WG_PRIVATE_KEY}"
          echo "Peer public key length: ${#WG_PEER_PUBLIC_KEY}"
          echo "Endpoint: ${WG_ENDPOINT}"
          echo "Endpoint length: ${#WG_ENDPOINT}"
          echo "AllowedIPs: ${WG_ALLOWED_IPS}"
          echo "AllowedIPs length: ${#WG_ALLOWED_IPS}"

          # Validate endpoint format (should be host:port)
          if [[ ! "$WG_ENDPOINT" =~ ^[^:]+:[0-9]+$ ]]; then
            echo "ERROR: WIREGUARD_ENDPOINT format is invalid!"
            echo "Expected format: hostname:port or ip:port"
            echo "Example: vpn.example.com:51820 or 203.0.113.1:51820"
            exit 1
          fi

          # Extract hostname and test DNS resolution
          WG_HOST=$(echo "$WG_ENDPOINT" | cut -d: -f1)
          WG_PORT=$(echo "$WG_ENDPOINT" | cut -d: -f2)
          echo ""
          echo "=== Testing endpoint resolution ==="
          echo "Host part: ${WG_HOST:0:10}... (first 10 chars)"
          echo "Port: $WG_PORT"

          # Test if hostname resolves
          if ! getent hosts "$WG_HOST" > /dev/null 2>&1; then
            echo "WARNING: Cannot resolve hostname '$WG_HOST'"
            echo "Trying direct IP check..."
            if [[ ! "$WG_HOST" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ERROR: Not a valid IP address either!"
              echo "Please check your WIREGUARD_ENDPOINT secret."
              echo "It should be either:"
              echo "  - A resolvable hostname with port (e.g., vpn.example.com:51820)"
              echo "  - An IP address with port (e.g., 203.0.113.1:51820)"
              exit 1
            else
              echo "Valid IP format detected, continuing..."
            fi
          else
            echo "Hostname resolves successfully"
          fi

          # Create WireGuard config
          sudo mkdir -p /etc/wireguard

          # Write config with cleaned values
          sudo tee /etc/wireguard/wg0.conf > /dev/null <<EOF
          [Interface]
          Address = ${WG_ADDRESS}
          PrivateKey = ${WG_PRIVATE_KEY}

          [Peer]
          PublicKey = ${WG_PEER_PUBLIC_KEY}
          Endpoint = ${WG_ENDPOINT}
          AllowedIPs = ${WG_ALLOWED_IPS}
          PersistentKeepalive = 25
          EOF

          sudo chmod 600 /etc/wireguard/wg0.conf

          # Debug: Show config structure (secrets will be masked by GitHub)
          echo "=== WireGuard config structure ==="
          sudo cat /etc/wireguard/wg0.conf

          echo ""
          echo "=== Config file line count ==="
          sudo wc -l /etc/wireguard/wg0.conf

          echo ""
          echo "=== Checking for invalid characters ==="
          sudo cat -A /etc/wireguard/wg0.conf | head -20

          # Connect
          echo ""
          echo "=== Attempting to bring up WireGuard ==="
          sudo wg-quick up wg0

          # Test connection
          ping -c 3 10.50.0.20

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.K3S_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Configure SSH with keep-alive settings to prevent connection drops
          cat >> ~/.ssh/config <<EOF
          Host *
            ServerAliveInterval 30
            ServerAliveCountMax 10
            TCPKeepAlive yes
            ConnectionAttempts 3
          EOF

          # Add host key (use private IP if WireGuard, public if direct)
          if [ "${{ env.USE_WIREGUARD }}" == "true" ]; then
            # For WireGuard, accept any host key for the private IP (since it's over VPN)
            echo "Host 10.50.0.20" >> ~/.ssh/config
            echo "  StrictHostKeyChecking no" >> ~/.ssh/config
            echo "  UserKnownHostsFile /dev/null" >> ~/.ssh/config
          else
            # For direct SSH, use the provided host key
            echo "${{ secrets.K3S_HOST }} ssh-rsa ${{ secrets.K3S_HOST_KEY }}" >> ~/.ssh/known_hosts
          fi

      - name: Deploy with Ansible (Beta Environment)
        env:
          REGISTRY_USER: ${{ secrets.DOCKER_USERNAME }}
          REGISTRY_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          # Use the image built by CI workflow (sha-<full_sha> format)
          IMAGE_TAG: sha-${{ github.event.workflow_run.head_sha || github.sha }}
          K3S_HOST: ${{ env.USE_WIREGUARD == 'true' && '10.50.0.20' || secrets.K3S_HOST }}
          K3S_USER: ${{ secrets.K3S_USER }}
          DB_HOST: ${{ secrets.DB_HOST_BETA || secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT_BETA || secrets.DB_PORT }}
          DB_NAME: ${{ secrets.DB_NAME_BETA || 'calendar_beta' }}
          DB_USER: ${{ secrets.DB_USER_BETA || secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD_BETA || secrets.DB_PASSWORD }}
          OBJECT_STORAGE_REGION: ${{ secrets.OBJECT_STORAGE_REGION }}
          OBJECT_STORAGE_BUCKET_NAME: ${{ secrets.OBJECT_STORAGE_BUCKET_NAME_BETA || secrets.OBJECT_STORAGE_BUCKET_NAME }}
          OBJECT_STORAGE_ENDPOINT_URL: ${{ secrets.OBJECT_STORAGE_ENDPOINT_URL }}
          OBJECT_STORAGE_CDN_URL: ${{ secrets.OBJECT_STORAGE_CDN_URL }}
          OBJECT_STORAGE_ACCESS_KEY: ${{ secrets.OBJECT_STORAGE_ACCESS_KEY }}
          OBJECT_STORAGE_SECRET_KEY: ${{ secrets.OBJECT_STORAGE_SECRET_KEY }}
          SESSION_ENCRYPTION_KEY: ${{ secrets.SESSION_ENCRYPTION_KEY_BETA || secrets.SESSION_ENCRYPTION_KEY }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          INGRESS_HOST: calendar-beta.villagecompute.com
          DEPLOYMENT_NAMESPACE: ${{ env.DEPLOYMENT_NAMESPACE }}
        run: |
          # Install Ansible
          python -m pip install --upgrade pip
          pip install ansible docker

          # Create inventory
          cat > inventory.yml <<EOF
          all:
            hosts:
              k3s_cluster:
                ansible_host: ${K3S_HOST}
                ansible_user: ${K3S_USER}
                ansible_ssh_private_key_file: ~/.ssh/id_rsa
                ansible_python_interpreter: /usr/bin/python3
          EOF

          # Run deployment (override namespace for beta)
          ansible-playbook \
            -i inventory.yml \
            -e "k8s_namespace=${DEPLOYMENT_NAMESPACE}" \
            ansible/deploy-calendar.yml

      - name: Wait for rollout completion
        env:
          K3S_HOST: ${{ env.USE_WIREGUARD == 'true' && '10.50.0.20' || secrets.K3S_HOST }}
          K3S_USER: ${{ secrets.K3S_USER }}
        run: |
          ssh -o StrictHostKeyChecking=no ${K3S_USER}@${K3S_HOST} \
            "kubectl rollout status deployment/calendar -n ${DEPLOYMENT_NAMESPACE} --timeout=5m"

      - name: Run smoke tests
        env:
          K3S_HOST: ${{ env.USE_WIREGUARD == 'true' && '10.50.0.20' || secrets.K3S_HOST }}
          K3S_USER: ${{ secrets.K3S_USER }}
        run: |
          echo "Running health check..."
          HEALTH_OUTPUT=$(ssh -o StrictHostKeyChecking=no ${K3S_USER}@${K3S_HOST} \
            "kubectl run smoke-test-health --rm -i --restart=Never --image=curlimages/curl:latest -n ${DEPLOYMENT_NAMESPACE} -- \
            curl -s -o /dev/null -w '%{http_code}' http://calendar-service.${DEPLOYMENT_NAMESPACE}.svc.cluster.local/q/health/live" 2>&1)

          # Extract just the HTTP status code (first 3 digits)
          HEALTH_STATUS=$(echo "${HEALTH_OUTPUT}" | grep -oE '^[0-9]{3}' | head -1)

          echo "Health check output: ${HEALTH_OUTPUT}"
          echo "Health check status: ${HEALTH_STATUS}"
          if [ "${HEALTH_STATUS}" != "200" ]; then
            echo "Health check failed with status ${HEALTH_STATUS}"
            exit 1
          fi

          echo "Running GraphQL smoke test..."
          GRAPHQL_OUTPUT=$(ssh -o StrictHostKeyChecking=no ${K3S_USER}@${K3S_HOST} \
            "kubectl run smoke-test-graphql --rm -i --restart=Never --image=curlimages/curl:latest -n ${DEPLOYMENT_NAMESPACE} -- \
            curl -s -X POST http://calendar-service.${DEPLOYMENT_NAMESPACE}.svc.cluster.local/graphql \
            -H 'Content-Type: application/json' \
            -d '{\"query\":\"query { __typename }\"}'") 2>&1

          # Filter out kubectl messages, keep only JSON response
          GRAPHQL_RESPONSE=$(echo "${GRAPHQL_OUTPUT}" | grep -v "^pod " | head -1)

          echo "GraphQL response: ${GRAPHQL_RESPONSE}"
          if echo "${GRAPHQL_RESPONSE}" | grep -q '"errors"'; then
            echo "GraphQL query failed"
            exit 1
          fi

          echo "All smoke tests passed!"

      - name: Upload generated manifest for debugging
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: k8s-manifest-beta
          path: /tmp/calendar-k8s.yaml
          retention-days: 1

      - name: Disconnect WireGuard
        if: always() && env.USE_WIREGUARD == 'true'
        run: |
          sudo wg-quick down wg0 || true

      - name: Notify deployment
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const sha = '${{ github.sha }}';
            const shortSha = sha.substring(0, 7);

            if (context.payload.pull_request) {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `âœ… Deployed to beta environment (${shortSha})\n\nView at: https://calendar-beta.villagecompute.com`
              });
            }
